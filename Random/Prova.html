<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>StreamFlix Pro</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>/* Tailwind config invariata */</script>
  <style>/* Stili invariati */</style>
</head>
<body class="bg-gradient-to-br from-dark via-secondary to-black text-white font-sans antialiased overflow-x-hidden">
  <!-- Struttura HTML Invariata -->
  <div class="fixed inset-0 bg-gradient-to-br from-dark via-secondary to-black opacity-90 z-0"></div>
  <div class="fixed inset-0 bg-[url('data:image/svg+xml,%3Csvg width="60" height="60" viewBox="0 0 60 60" xmlns="http://www.w3.org/2000/svg"%3E%3Cg fill="none" fill-rule="evenodd"%3E%3Cg fill="%23ffffff" fill-opacity="0.02"%3E%3Ccircle cx="30" cy="30" r="1"/%3E%3C/g%3E%3C/g%3E%3C/svg%3E')] z-0"></div>

  <header class="relative z-50 glass-effect sticky top-0">
    <!-- Header Invariato -->
  </header>

  <main class="relative z-10 max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <div id="loading" class="hidden flex justify-center items-center py-20">
      <div class="animate-spin rounded-full h-16 w-16 border-4 border-gray-600 border-t-primary"></div>
    </div>
    <div id="gallery" class="animate-fade-in"></div>
    <div id="no-results" class="hidden text-center py-20">
      <div class="text-6xl mb-4">üîç</div>
      <h3 class="text-2xl font-bold mb-2">Nessun risultato trovato</h3>
      <p class="text-gray-400">Prova a modificare i tuoi filtri di ricerca</p>
    </div>
  </main>

  <footer class="relative z-10 glass-effect mt-20 py-8">
    <!-- Footer Invariato -->
  </footer>

  <script>
    const dataFiles = { /* ... (invariato) ... */ };
    let currentType = 'anime', rawData = [], flatItems = [];
    const gallery = document.getElementById('gallery'); /* ... (altre costanti DOM invariate) ... */

    function updateActiveNav(activeType) { /* ... (invariato) ... */ }

    async function loadData(type, skipRender = false) {
      return new Promise(async (resolve, reject) => {
        // ... (logica di caricamento e flattening dati come prima, assicurandosi che `item.id` sia usato per `serieId`) ...
        if (!skipRender) { loading.classList.remove('hidden'); gallery.classList.add('hidden'); noResults.classList.add('hidden'); }
        currentType = type;
        rawData = []; flatItems = [];
        if (!skipRender) { updateActiveNav(type); }
        try {
          const res = await fetch(dataFiles[type]);
          if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
          const jsonData = await res.json();
          rawData = jsonData;
          if (['anime', 'series_tv'].includes(type)) {
            rawData.forEach((item) => {
              if (item.seasons && Array.isArray(item.seasons)) {
                item.seasons.forEach((season, seasonIndex) => {
                  if (season.episodes && Array.isArray(season.episodes)) {
                    season.episodes.forEach((ep, episodeIndex) => {
                      flatItems.push({ ...ep, serieId: item.id, serieTitle: item.title, seasonName: season.name, seasonIndex, episodeIndex, poster: ep.still_path || item.poster_path, genres: item.genres || [] });
                    });
                  }
                });
              }
            });
          } else { 
            flatItems = rawData.map((f) => ({ ...f, serieId: f.id, serieTitle: f.title, seasonName: '', seasonIndex: -1, episodeIndex: -1, poster: f.poster_path, genres: f.genres || [] }));
          }
          if (!skipRender) { populateGenres(); renderGallery(); }
          resolve();
        } catch (error) {
          console.error('Errore caricamento dati:', error);
          if (!skipRender) { gallery.innerHTML = '<div class="text-center py-20"><div class="text-6xl mb-4">‚ö†Ô∏è</div><h3 class="text-2xl font-bold mb-2">Errore</h3><p class="text-gray-400">Impossibile caricare</p></div>'; }
          reject(error);
        } finally {
          if (!skipRender) { loading.classList.add('hidden'); if (gallery.innerHTML !== '' || noResults.classList.contains('hidden')) { gallery.classList.remove('hidden');}}
        }
      });
    }

    function populateGenres() { /* ... (invariato) ... */ }

    function renderGallery() {
      // ... (logica di rendering come prima, MA nel card.addEventListener('click', ...)) ...
      // Per serie/anime:
      // card.addEventListener('click', () => {
      //   const serieDataForPlayer = rawData.find(s => s.id === ep.serieId); // Trova l'intera serie
      //   if (serieDataForPlayer) {
      //       localStorage.setItem(`serieData_${ep.serieId}`, JSON.stringify(serieDataForPlayer));
      //       console.log(`Dati per serie ${ep.serieId} salvati in localStorage.`);
      //   } else {
      //       console.warn(`Impossibile trovare i dati completi per la serie ${ep.serieId} per localStorage.`);
      //   }

      //   const params = new URLSearchParams({
      //     videoUrl: ep.file,
      //     contentType: currentType,
      //     serieId: ep.serieId, 
      //     title: ep.serieTitle, 
      //     seasonName: ep.seasonName,
      //     stagioneIndex: ep.seasonIndex.toString(),
      //     episodeIndex: ep.episodeIndex.toString(),
      //     skipIntroStart: ep.skipIntroStart || '',
      //     skipIntroEnd: ep.skipIntroEnd || '',
      //     outroStart: ep.outroStart || '',
      //     returnTo: window.location.pathname + window.location.search 
      //   });
      //   window.location.href = `player.html?${params.toString()}`;
      // });
      // Per film:
      // card.addEventListener('click', () => {
      //    localStorage.removeItem(`serieData_${item.serieId}`); // Rimuovi eventuali dati vecchi se √® un film
      //    const params = new URLSearchParams({ /* ... parametri film ... */ });
      //    window.location.href = `player.html?${params.toString()}`;
      // });
      const q = searchInput.value.toLowerCase();
      const g = genreFilter.value;
      let hasResults = false;
      gallery.innerHTML = ''; 
      
      if (['anime', 'series_tv'].includes(currentType)) {
        const seriesMap = new Map();
        flatItems.forEach(epFlat => { // epFlat √® un episodio da flatItems
            const originalSerie = rawData.find(s => s.id === epFlat.serieId);
            if (!originalSerie) return; // Serie non trovata in rawData

            // Filtra per ricerca e genere a livello di serie o episodio
            const matchesSearch = originalSerie.title.toLowerCase().includes(q) || epFlat.name.toLowerCase().includes(q);
            const matchesGenre = !g || (originalSerie.genres && originalSerie.genres.includes(g));

            if (!matchesSearch || !matchesGenre) return;

            if (!seriesMap.has(epFlat.serieId)) {
                seriesMap.set(epFlat.serieId, { 
                    id: originalSerie.id, 
                    title: originalSerie.title, 
                    poster_path: originalSerie.poster_path, 
                    genres: originalSerie.genres,
                    seasonsData: originalSerie.seasons, // Aggiungiamo tutte le stagioni qui
                    seasonsMap: new Map() // Per gli episodi filtrati da mostrare
                });
            }
            const serieEntry = seriesMap.get(epFlat.serieId);
            if (!serieEntry.seasonsMap.has(epFlat.seasonIndex)) {
                serieEntry.seasonsMap.set(epFlat.seasonIndex, { 
                    name: epFlat.seasonName, 
                    seasonIndex: epFlat.seasonIndex, 
                    episodes: [] 
                });
            }
            serieEntry.seasonsMap.get(epFlat.seasonIndex).episodes.push(epFlat); // epFlat ha gi√† tutti i dati necessari
            hasResults = true;
        });

        seriesMap.forEach(serie => { // serie qui √® l'oggetto da seriesMap
            const section = document.createElement('section');
            section.className = 'mb-12 animate-slide-up';
            const titleEl = document.createElement('h2');
            titleEl.textContent = serie.title;
            titleEl.className = 'text-3xl lg:text-4xl font-bold mb-6 gradient-text';
            section.appendChild(titleEl);
            
            Array.from(serie.seasonsMap.values()).sort((a,b) => a.seasonIndex - b.seasonIndex).forEach(seasonDisplay => { // seasonDisplay √® per la visualizzazione
              const seasonTitle = document.createElement('h3');
              seasonTitle.textContent = seasonDisplay.name;
              seasonTitle.className = 'text-xl lg:text-2xl font-semibold mb-4 text-accent';
              section.appendChild(seasonTitle);
              
              const grid = document.createElement('div');
              grid.className = 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 lg:gap-6 mb-8';
              
              seasonDisplay.episodes.sort((a,b) => a.episodeIndex - b.episodeIndex).forEach(ep => { // ep √® un episodio da flatItems
                const card = document.createElement('div');
                card.className = 'card-hover cursor-pointer glass-effect rounded-xl overflow-hidden';
                card.innerHTML = `
                  <div class="relative"><img src="${ep.poster}" class="w-full h-24 sm:h-32 lg:h-40 object-cover" loading="lazy" onerror="this.onerror=null;this.src='data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' viewBox=\\'0 0 400 300\\'%3E%3Crect width=\\'100%25\\' height=\\'100%25\\' fill=\\'%23333\\'/%3E%3Ctext x=\\'50%25\\' y=\\'50%25\\' fill=\\'%23999\\' text-anchor=\\'middle\\' dy=\\'.3em\\'%3EImmagine non disponibile%3C/text%3E%3C/svg%3E';"/>
                    <div class="absolute inset-0 bg-gradient-to-t from-black/80 via-transparent to-transparent opacity-0 hover:opacity-100 transition-opacity duration-300 flex items-end">
                      <div class="p-3"><div class="w-12 h-12 bg-primary rounded-full flex items-center justify-center"><svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></div></div>
                    </div>
                  </div>
                  <div class="p-3"><p class="text-sm lg:text-base font-medium truncate">${ep.name}</p><p class="text-xs text-gray-400 mt-1">Episodio ${ep.episode_number || (ep.episodeIndex + 1)}</p></div>`;
                
                card.addEventListener('click', () => {
                  // Salva l'intera struttura della serie (con tutte le stagioni/episodi) in localStorage
                  const fullSerieDataForPlayer = rawData.find(s => s.id === ep.serieId);
                  if (fullSerieDataForPlayer) {
                      localStorage.setItem(`serieData_${ep.serieId}`, JSON.stringify(fullSerieDataForPlayer));
                      console.log(`Dati per serie ${ep.serieId} salvati in localStorage.`);
                  } else {
                      console.warn(`Impossibile trovare i dati completi per la serie ${ep.serieId}.`);
                  }

                  const params = new URLSearchParams({
                    videoUrl: ep.file,
                    contentType: currentType,
                    serieId: ep.serieId, 
                    title: ep.serieTitle, 
                    seasonName: ep.seasonName, // Questo viene da flatItems, gi√† corretto
                    stagioneIndex: ep.seasonIndex.toString(),
                    episodeIndex: ep.episodeIndex.toString(),
                    skipIntroStart: ep.skipIntroStart || '',
                    skipIntroEnd: ep.skipIntroEnd || '',
                    outroStart: ep.outroStart || '',
                    returnTo: window.location.pathname + window.location.search 
                  });
                  window.location.href = `player.html?${params.toString()}`;
                });
                grid.appendChild(card);
              });
              section.appendChild(grid);
            });
            gallery.appendChild(section);
        });
      } else { /* ... (logica film invariata, ma assicurati di fare localStorage.removeItem(`serieData_...`) se necessario) ... */ 
        const filteredItemsToRender = flatItems.filter(i => 
          i.serieTitle.toLowerCase().includes(q) && (!g || i.genres.includes(g))
        );
        if (filteredItemsToRender.length > 0) {
          hasResults = true;
          const grid = document.createElement('div');
          grid.className = 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 lg:gap-6 animate-slide-up';
          filteredItemsToRender.forEach(item => {
            const card = document.createElement('div');
            card.className = 'card-hover cursor-pointer glass-effect rounded-xl overflow-hidden';
            card.innerHTML = `
              <div class="relative"><img src="${item.poster}" class="w-full h-48 sm:h-56 lg:h-64 object-cover" loading="lazy" onerror="this.onerror=null;this.src='data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' viewBox=\\'0 0 400 600\\'%3E%3Crect width=\\'100%25\\' height=\\'100%25\\' fill=\\'%23333\\'/%3E%3Ctext x=\\'50%25\\' y=\\'50%25\\' fill=\\'%23999\\' text-anchor=\\'middle\\' dy=\\'.3em\\'%3EImmagine non disponibile%3C/text%3E%3C/svg%3E';"/>
                <div class="absolute inset-0 bg-gradient-to-t from-black/80 via-transparent to-transparent opacity-0 hover:opacity-100 transition-opacity duration-300 flex items-center justify-center">
                  <div class="w-16 h-16 bg-primary rounded-full flex items-center justify-center animate-pulse"><svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></div>
                </div>
              </div>
              <div class="p-4"><h3 class="text-sm lg:text-base font-bold truncate">${item.serieTitle}</h3>
                ${item.genres && item.genres.length > 0 ? `<p class="text-xs text-gray-400 mt-1">${item.genres.slice(0, 2).join(', ')}</p>` : ''}</div>`;
            card.addEventListener('click', () => {
              localStorage.removeItem(`serieData_${item.serieId}`); // Pulisci per film
              const params = new URLSearchParams({
                videoUrl: item.url_video, contentType: currentType, serieId: item.serieId, title: item.serieTitle, returnTo: window.location.pathname + window.location.search
              });
              window.location.href = `player.html?${params.toString()}`;
            });
            grid.appendChild(card);
          });
          gallery.appendChild(grid);
        }
      }
      noResults.classList.toggle('hidden', !hasResults);
    }


    async function playNextHandler() {
      if (window.location.hash.startsWith('#playNext?')) {
        const hashParams = new URLSearchParams(window.location.hash.substring(window.location.hash.indexOf('?') + 1));
        const serieIdParam = hashParams.get('serieId');
        const contentTypeParam = hashParams.get('contentType');
        const currentSeasonIndexParam = parseInt(hashParams.get('stagioneIndex'), 10);
        const currentEpisodeIndexParam = parseInt(hashParams.get('episodioIndex'), 10);
        const returnToParam = decodeURIComponent(hashParams.get('returnTo') || 'Casa.html');


        if (!serieIdParam || !contentTypeParam || isNaN(currentSeasonIndexParam) || isNaN(currentEpisodeIndexParam)) {
          console.error("Parametri #playNext mancanti o non validi.");
          window.location.hash = ''; loadData(currentType); return;
        }
        try {
            await loadData(contentTypeParam, true); 
        } catch (e) {
            console.error("Errore caricamento dati per playNext:", e);
            alert("Impossibile caricare i dati per l'episodio successivo.");
            window.location.href = returnToParam; return;
        }

        const serie = rawData.find(s => s.id === serieIdParam);
        if (!serie) {
          console.error(`Serie con ID ${serieIdParam} non trovata.`);
          window.location.href = returnToParam; return;
        }
        // Salva i dati della serie corrente in localStorage per il player
        localStorage.setItem(`serieData_${serie.id}`, JSON.stringify(serie));

        let nextEpisode = null, nextSeasonIndex = currentSeasonIndexParam, nextEpisodeIndex = currentEpisodeIndexParam + 1;
        if (serie.seasons && serie.seasons[currentSeasonIndexParam] && serie.seasons[currentSeasonIndexParam].episodes[nextEpisodeIndex]) {
          nextEpisode = serie.seasons[currentSeasonIndexParam].episodes[nextEpisodeIndex];
        } else {
          nextSeasonIndex = currentSeasonIndexParam + 1; nextEpisodeIndex = 0;
          if (serie.seasons && serie.seasons[nextSeasonIndex] && serie.seasons[nextSeasonIndex].episodes[nextEpisodeIndex]) {
            nextEpisode = serie.seasons[nextSeasonIndex].episodes[nextEpisodeIndex];
          }
        }
        if (nextEpisode) {
          const paramsToPlayer = new URLSearchParams({
            videoUrl: nextEpisode.file, contentType: contentTypeParam, serieId: serie.id, title: serie.title,
            seasonName: serie.seasons[nextSeasonIndex].name, stagioneIndex: nextSeasonIndex.toString(), episodeIndex: nextEpisodeIndex.toString(),
            skipIntroStart: nextEpisode.skipIntroStart || '', skipIntroEnd: nextEpisode.skipIntroEnd || '', outroStart: nextEpisode.outroStart || '',
            returnTo: returnToParam
          });
          window.location.hash = ''; window.location.href = `player.html?${paramsToPlayer.toString()}`;
        } else {
          console.log("Fine della serie o stagione non trovata.");
          window.location.hash = '';
          window.location.href = returnToParam.includes('player.html') ? 'Casa.html' : returnToParam;
        }
      } else {
        loadData(currentType);
      }
    }

    searchInput.addEventListener('input', debounce(renderGallery, 300));
    genreFilter.addEventListener('change', renderGallery);
    navButtons.forEach(btn => btn.addEventListener('click', () => {
        if (window.location.hash.startsWith('#playNext')) { window.location.hash = '';}
        loadData(btn.dataset.type);
    }));
    function debounce(func, wait) { /* ... (invariato) ... */ }
    document.addEventListener('keydown', (e) => { /* ... (invariato) ... */ });
    document.addEventListener('DOMContentLoaded', () => { playNextHandler(); });
  </script>
</body>
</html>
