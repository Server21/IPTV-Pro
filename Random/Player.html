<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Player Video Avanzato</title>
  <link rel="icon" href="data:,">
  <style>
    :root {
      --player-background: #000;
      --player-text-color: #e0e0e0;
      --player-highlight-color: #e50914; /* Rosso Netflix-like */
      --player-control-bar-bg: linear-gradient(to top, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.6) 60%, transparent 100%);
      --progress-bar-bg: rgba(255,255,255,0.2);
      --progress-filled-bg: var(--player-highlight-color);
      --progress-buffered-bg: rgba(255,255,255,0.4);
      --progress-handle-bg: var(--player-highlight-color);
      --progress-handle-border: #fff;
      --tooltip-bg: rgba(0,0,0,0.9);
      --select-bg: #2a2a2a;
      --select-border-color: #555;
      --button-bg-hover: rgba(255,255,255,0.2);
    }

    body { 
      margin: 0; 
      background: #0e0e0e; 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      height: 100vh; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
      color: var(--player-text-color); 
      overflow: hidden; 
    }
    .player-container { 
      position: relative; 
      width: 90%; 
      max-width: 1000px; 
      background: var(--player-background); 
      border-radius: 12px; 
      overflow: hidden; 
      box-shadow: 0 10px 40px rgba(0,0,0,0.7); 
      aspect-ratio: 16 / 9;
    }
    .player-container.fullscreen { 
      width: 100vw !important; 
      height: 100vh !important; 
      max-width: none !important; 
      border-radius: 0; 
      aspect-ratio: auto; 
    }
    video { 
      width: 100%; 
      height: 100%; 
      display: block; 
      background: var(--player-background); 
      cursor: pointer; 
      object-fit: contain; 
    }
    .pause-overlay { 
      position: absolute; 
      top: 50%; 
      left: 50%; 
      transform: translate(-50%, -50%); 
      font-size: 72px; 
      color: rgba(255,255,255,0.85); 
      display: none; 
      animation: fadeOverlay 0.5s ease-in-out; 
      pointer-events: none; 
      text-shadow: 0 0 15px rgba(0,0,0,0.5); 
    }
    @keyframes fadeOverlay { 
      from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); } 
      to { opacity: 1; transform: translate(-50%, -50%) scale(1); } 
    }
    .controls { 
      position: absolute; 
      bottom: 0; 
      left: 0; 
      right: 0; 
      background: var(--player-control-bar-bg); 
      padding: 10px 15px; 
      display: flex; 
      flex-direction: column; 
      gap: 8px; 
      opacity: 1; 
      transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out; 
      z-index: 2147483647; 
      transform: translateY(0%); 
    }
    .controls.hidden { 
      opacity: 0; 
      pointer-events: none; 
      transform: translateY(100%); 
    }
    .progress-bar-container { 
      display: flex; 
      align-items: center; 
      width: 100%; 
      order: 1; 
    }
    span#time-display { 
      color: var(--player-text-color); 
      font-size: 0.9em; 
      margin-right: 12px; 
      font-variant-numeric: tabular-nums; 
    }
    .progress-bar { 
      position: relative; 
      flex-grow: 1; 
      height: 6px; 
      background: var(--progress-bar-bg); 
      cursor: pointer; 
      border-radius: 3px; 
      transition: height 0.2s ease; 
    }
    .progress-bar:hover { height: 10px; }
    .progress-filled { 
      width: 0; 
      height: 100%; 
      background: var(--progress-filled-bg); 
      border-radius: 3px; 
    }
    .progress-buffered { 
      position: absolute; 
      top: 0; 
      left: 0; 
      width: 0; 
      height: 100%; 
      background: var(--progress-buffered-bg); 
      border-radius: 3px; 
      z-index: -1; 
    }
    .progress-handle { 
      position: absolute; 
      top: 50%; 
      left: 0; 
      width: 14px; 
      height: 14px; 
      background: var(--progress-handle-bg); 
      border: 2px solid var(--progress-handle-border); 
      border-radius: 50%; 
      transform: translate(-50%, -50%) scale(0); 
      cursor: grabbing; 
      opacity: 0; 
      transition: opacity 0.2s ease, transform 0.2s ease; 
      z-index: 3; 
      box-shadow: 0 0 8px rgba(0,0,0,0.5); 
    }
    .progress-bar:hover .progress-handle, .progress-handle.dragging { 
      opacity: 1; 
      transform: translate(-50%, -50%) scale(1); 
    }
    .preview-thumb { 
      position: absolute; 
      bottom: calc(100% + 10px); 
      left: 0; 
      width: 160px; 
      height: 90px; 
      background: #111; 
      border: 2px solid var(--player-highlight-color); 
      display: none; 
      pointer-events: none; 
      border-radius: 4px; 
      overflow: hidden; 
      box-shadow: 0 0 15px rgba(0,0,0,0.5);
    }
    .preview-thumb video { 
      width: 100%; 
      height: 100%; 
      object-fit: cover; 
    }
    .tooltip { 
      position: absolute; 
      bottom: calc(100% + 10px); 
      padding: 4px 8px; 
      background: var(--tooltip-bg); 
      color: #fff; 
      font-size:13px; 
      border-radius:3px; 
      transform: translateX(-50%); 
      display: none; 
      white-space:nowrap; 
      pointer-events: none; 
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
    }
    
    .controls-main { 
      display: flex; 
      align-items: center; 
      gap: 10px; 
      order: 2; 
      width: 100%; 
      justify-content: space-between; 
      padding-top: 5px; 
    }
    .controls-left, .controls-right { 
      display: flex; 
      align-items: center; 
      gap: 10px; 
    }
    .volume-control { 
      display: flex; 
      align-items: center; 
      gap:5px; 
    }
    .volume-control input[type=range] { 
      width: 70px; 
      cursor: pointer; 
      -webkit-appearance: none; 
      appearance: none; 
      background: transparent; 
    }
    .volume-control input[type=range]::-webkit-slider-runnable-track { 
      height: 5px; 
      background: var(--progress-bar-bg); 
      border-radius: 3px; 
    }
    .volume-control input[type=range]::-webkit-slider-thumb { 
      -webkit-appearance: none; 
      appearance: none; 
      margin-top: -4.5px; 
      width: 14px; 
      height: 14px; 
      background: var(--progress-handle-border); 
      border-radius: 50%; 
      border: 1px solid var(--player-highlight-color); 
    }
    .volume-control input[type=range]::-moz-range-track { 
      height: 5px; 
      background: var(--progress-bar-bg); 
      border-radius: 3px; 
    }
    .volume-control input[type=range]::-moz-range-thumb { 
      width: 12px; 
      height: 12px; 
      background: var(--progress-handle-border); 
      border-radius: 50%; 
      border: 1px solid var(--player-highlight-color); 
    }

    select.player-select { 
      background: var(--select-bg); 
      color: var(--player-text-color); 
      border: 1px solid var(--select-border-color); 
      border-radius:4px; 
      padding:7px 10px; 
      cursor: pointer; 
      font-size: 0.9em; 
      max-width: 200px; 
      transition: border-color 0.2s; 
    } 
    select.player-select:hover { border-color: var(--player-highlight-color); }
    #backToCatalogButton { 
      padding: 7px 14px; 
      background-color: rgba(255,255,255,0.1); 
      color: white; 
      border: none; 
      border-radius: 4px; 
      cursor: pointer; 
      font-size: 0.9em; 
      transition: background-color 0.2s;
    }
    #backToCatalogButton:hover { background-color: var(--button-bg-hover); }
    .episode-selector-group { 
      display: flex; 
      gap: 10px; 
      align-items: center;
    }
    .control-button { 
      background: none;
      border: none;
      color: var(--player-text-color);
      font-size: 1.5em; /* Aumenta leggermente la dimensione per le emoji */
      padding: 5px;
      cursor: pointer;
      line-height: 1; /* Per allineare meglio le emoji */
      transition: transform 0.1s ease; 
    }
    .control-button:active { transform: scale(0.9); }
  </style>
</head>
<body>
  <div class="player-container" id="playerContainer">
    <video id="video" playsinline poster="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" preload="metadata"></video> 
    <div class="pause-overlay" id="pauseOverlay">‚è∏Ô∏è</div>
    <div class="controls" id="controls">
      <div class="progress-bar-container">
        <span id="time-display">00:00 / 00:00</span>
        <div class="progress-bar" id="progressBar">
          <div class="progress-buffered" id="progressBuffered"></div>
          <div class="progress-filled" id="progressFilled"></div>
          <div class="progress-handle" id="progressHandle"></div>
          <div class="preview-thumb" id="previewThumb"><video muted playsinline preload="metadata"></video></div>
          <div class="tooltip" id="tooltip">00:00</div>
        </div>
      </div>
      
      <div class="controls-main">
        <div class="controls-left">
            <button class="control-button" id="playPauseBtn" title="Play/Pausa" aria-label="Play">‚ñ∂Ô∏è</button>
            <button class="control-button" id="backToCatalogButton" title="Torna al Catalogo">‚Üê</button> 
            <div id="episodeSelectorGroup" class="episode-selector-group" style="display: none;">
              <select id="seasonSelector" class="player-select" title="Seleziona Stagione" aria-label="Seleziona Stagione"></select>
              <select id="episodeSelector" class="player-select" title="Seleziona Episodio" aria-label="Seleziona Episodio"></select>
            </div>
        </div>
        <div class="controls-right">
            <div class="volume-control">
              <span id="volumeIcon" class="control-button" style="cursor:pointer;" title="Muto/Audio" aria-label="Audio Attivo">üîä</span>
              <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1" title="Volume" aria-label="Regola Volume">
            </div>
            <select id="speedSelector" title="Velocit√†" class="player-select" aria-label="Seleziona Velocit√†">
              <option value="0.5">0.5x</option><option value="0.75">0.75x</option>
              <option value="1" selected>1x</option><option value="1.25">1.25x</option>
              <option value="1.5">1.5x</option><option value="2">2x</option>
            </select>
            <button class="control-button" id="fullscreenBtn" title="Schermo Intero" aria-label="Attiva Schermo Intero">‚õ∂</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script>
    (function() {
      'use strict';

      // --- Helper Functions ---
      function parseTime(timeString) {
          if (typeof timeString !== 'string') return 0;
          const parts = timeString.split(':').map(Number);
          let seconds = 0;
          if (parts.length === 3) { // HH:MM:SS
              seconds = (parts[0] * 3600) + (parts[1] * 60) + parts[2];
          } else if (parts.length === 2) { // MM:SS
              seconds = (parts[0] * 60) + parts[1];
          } else if (parts.length === 1) { // SS
              seconds = parts[0];
          }
          return isNaN(seconds) ? 0 : Math.max(0, seconds);
      }

      function formatTime(s) { 
          if (isNaN(s) || !isFinite(s) || s < 0) return '00:00'; 
          const m = Math.floor(s / 60); 
          const sec = Math.floor(s % 60); 
          return `${m.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`; 
      }

      // --- URL Params and CONFIG setup ---
      const urlParams = new URLSearchParams(window.location.search);
      const CONFIG = {
        source: urlParams.get('videoUrl') || '', 
        startTime: urlParams.get('startTime') || '0:00',
        skipIntroStart: urlParams.get('skipIntroStart'), 
        skipIntroEnd: urlParams.get('skipIntroEnd'),
        outroStart: urlParams.get('outroStart'),
        serieId: urlParams.get('serieId'), 
        stagioneIndex: parseInt(urlParams.get('stagioneIndex'), 10), 
        episodioIndex: parseInt(urlParams.get('episodioIndex'), 10), 
        contentType: urlParams.get('contentType'), 
        title: urlParams.get('title') || 'Video Player', 
        returnTo: urlParams.get('returnTo') || 'StreamRoot.html'
      };
      console.log("[VideoPlayer] CONFIG iniziale:", JSON.parse(JSON.stringify(CONFIG)));
      document.title = CONFIG.title; 

      let isFilmSimple = !CONFIG.contentType || CONFIG.contentType === 'film' || !CONFIG.serieId;
      let initialStartTime = parseTime(CONFIG.startTime); 
      let skipIntroStart = !isFilmSimple && CONFIG.skipIntroStart ? parseTime(CONFIG.skipIntroStart) : 0;
      let skipIntroEnd = !isFilmSimple && CONFIG.skipIntroEnd ? parseTime(CONFIG.skipIntroEnd) : 0;
      let outroStart = !isFilmSimple && CONFIG.outroStart ? parseTime(CONFIG.outroStart) : 0;
      let currentSerieData = null; 

      // --- DOM Element Constants ---
      const playerContainer = document.getElementById('playerContainer');
      const video = document.getElementById('video');
      const pauseOverlay = document.getElementById('pauseOverlay');
      const controls = document.getElementById('controls');
      const progressBar = document.getElementById('progressBar');
      const progressFilled = document.getElementById('progressFilled');
      const progressBuffered = document.getElementById('progressBuffered');
      const progressHandle = document.getElementById('progressHandle');
      const timeDisplay = document.getElementById('time-display');
      const previewThumb = document.getElementById('previewThumb');
      const previewVideo = previewThumb.querySelector('video');
      const tooltip = document.getElementById('tooltip');
      const speedSelector = document.getElementById('speedSelector');
      const volumeSlider = document.getElementById('volumeSlider');
      const volumeIcon = document.getElementById('volumeIcon');
      const playPauseBtn = document.getElementById('playPauseBtn');
      const backToCatalogButton = document.getElementById('backToCatalogButton');
      const fullscreenBtn = document.getElementById('fullscreenBtn');
      const episodeSelectorGroup = document.getElementById('episodeSelectorGroup');
      const seasonSelector = document.getElementById('seasonSelector');
      const episodeSelector = document.getElementById('episodeSelector');

      // --- State Variables ---
      let isDraggingSeekBar = false;
      let hideControlsTimeout;
      let hlsInstance = null;
      let hasAttemptedInitialFullscreen = false;
      let isUserInteracted = false; 

      // --- User Interaction Listener (per autoplay e fullscreen) ---
      function userInteractionHandler() {
          if (isUserInteracted) return;
          isUserInteracted = true;
          document.removeEventListener('click', userInteractionHandler);
          document.removeEventListener('keydown', userInteractionHandler);
          document.removeEventListener('touchstart', userInteractionHandler); 
          console.log("[VideoPlayer] Interazione utente rilevata.");
          if (video.paused && video.readyState >= video.HAVE_FUTURE_DATA && CONFIG.source) { // Solo se c'√® una sorgente
              video.play().catch(e => console.warn("[VideoPlayer] Play post-interazione non riuscito:", e.message));
          }
      }
      document.addEventListener('click', userInteractionHandler);
      document.addEventListener('keydown', userInteractionHandler);
      document.addEventListener('touchstart', userInteractionHandler);


      // --- Serie/Episode Data Logic ---
      function loadSerieDataFromStorage() {
          console.log("[VideoPlayer] Tentativo caricamento dati serie da localStorage per serieId:", CONFIG.serieId);
          if (CONFIG.serieId && (CONFIG.contentType === 'anime' || CONFIG.contentType === 'series_tv')) {
              const storedData = localStorage.getItem(`serieData_${CONFIG.serieId}`);
              if (storedData) {
                  try {
                      currentSerieData = JSON.parse(storedData);
                      isFilmSimple = false; 
                      console.log("[VideoPlayer] Dati serie caricati e parsati:", currentSerieData);
                      populateSeasonSelector();
                  } catch (e) { 
                      console.error("[VideoPlayer] Errore parsing dati serie:", e); 
                      currentSerieData = null; isFilmSimple = true; 
                  }
              } else { 
                  console.warn(`[VideoPlayer] Nessun dato serie per ID: ${CONFIG.serieId}. Considerato come film.`); 
                  isFilmSimple = true; 
              }
          } else { isFilmSimple = true; }
          episodeSelectorGroup.style.display = (!isFilmSimple && currentSerieData) ? 'flex' : 'none';
          console.log("[VideoPlayer] Visibilit√† selettori episodi:", episodeSelectorGroup.style.display);
      }
      
      function populateSeasonSelector() {
          seasonSelector.innerHTML = ''; 
          if (!currentSerieData || !currentSerieData.seasons || currentSerieData.seasons.length === 0) {
              const defaultOption = new Option("Nessuna stagione", "");
              defaultOption.disabled = true; seasonSelector.add(defaultOption);
              populateEpisodeSelector(-1); return;
          }
          currentSerieData.seasons.forEach((season, index) => {
              const seasonName = season.name || season.title || `Stagione ${index + 1}`;
              const option = new Option(seasonName, index.toString());
              seasonSelector.add(option);
          });
          if (!isNaN(CONFIG.stagioneIndex) && CONFIG.stagioneIndex < currentSerieData.seasons.length && CONFIG.stagioneIndex >= 0) {
              seasonSelector.value = CONFIG.stagioneIndex.toString();
          } else if (currentSerieData.seasons.length > 0) {
              CONFIG.stagioneIndex = 0; seasonSelector.value = "0";
          }
          populateEpisodeSelector(CONFIG.stagioneIndex); // Usa l'indice aggiornato o di default
      }

      function populateEpisodeSelector(seasonIdx) {
          episodeSelector.innerHTML = ''; 
          if (isNaN(seasonIdx) || seasonIdx < 0 || !currentSerieData || !currentSerieData.seasons[seasonIdx] || !currentSerieData.seasons[seasonIdx].episodes || currentSerieData.seasons[seasonIdx].episodes.length === 0) {
              const defaultOption = new Option("Nessun episodio", "");
              defaultOption.disabled = true; episodeSelector.add(defaultOption); return;
          }
          const episodes = currentSerieData.seasons[seasonIdx].episodes;
          episodes.forEach((episode, index) => {
              const episodeTitle = episode.title || episode.name || `Episodio ${index + 1}`;
              const option = new Option(episodeTitle, index.toString());
              episodeSelector.add(option);
          });
          if (!isNaN(CONFIG.episodioIndex) && parseInt(seasonSelector.value, 10) === CONFIG.stagioneIndex && CONFIG.episodioIndex < episodes.length && CONFIG.episodioIndex >= 0) {
            episodeSelector.value = CONFIG.episodioIndex.toString();
          } else if (episodes.length > 0) {
             CONFIG.episodioIndex = 0; episodeSelector.value = "0";
          }
      }

      seasonSelector.addEventListener('change', (e) => {
          const newSeasonIndex = parseInt(e.target.value, 10);
          if (!isNaN(newSeasonIndex)) {
              CONFIG.stagioneIndex = newSeasonIndex;
              CONFIG.episodioIndex = 0; 
              populateEpisodeSelector(newSeasonIndex);
              if (episodeSelector.options.length > 0 && !episodeSelector.options[0].disabled) {
                  playEpisode(CONFIG.stagioneIndex, CONFIG.episodioIndex);
              }
          }
      });

      episodeSelector.addEventListener('change', (e) => {
          const newEpisodeIndex = parseInt(e.target.value, 10);
          if (!isNaN(newEpisodeIndex)) {
             playEpisode(CONFIG.stagioneIndex, newEpisodeIndex);
          }
      });
      
      function playEpisode(seasonIdx, episodeIdx) {
          console.log(`[VideoPlayer] Richiesta riproduzione Stagione ${seasonIdx + 1}, Episodio ${episodeIdx + 1}`);
          if (!currentSerieData || !currentSerieData.seasons[seasonIdx] || !currentSerieData.seasons[seasonIdx].episodes[episodeIdx]) {
              console.error("[VideoPlayer] Dati episodio non trovati per playEpisode."); return;
          }
          const episodeData = currentSerieData.seasons[seasonIdx].episodes[episodeIdx];
          if (!episodeData.file) { // 'file' √® usato in anime.json
              console.error("[VideoPlayer] URL video (file) per l'episodio non trovato."); return;
          }

          CONFIG.stagioneIndex = seasonIdx; CONFIG.episodioIndex = episodeIdx;
          CONFIG.source = episodeData.file;
          CONFIG.title = episodeData.name || episodeData.title || `Stagione ${seasonIdx + 1} - Episodio ${episodeIdx + 1}`;
          document.title = CONFIG.title;

          skipIntroStart = (episodeData.skipIntroStart ? parseTime(episodeData.skipIntroStart) : 0) || (currentSerieData.skipIntroStart ? parseTime(currentSerieData.skipIntroStart) : 0);
          skipIntroEnd = (episodeData.skipIntroEnd ? parseTime(episodeData.skipIntroEnd) : 0) || (currentSerieData.skipIntroEnd ? parseTime(currentSerieData.skipIntroEnd) : 0);
          outroStart = (episodeData.outroStart ? parseTime(episodeData.outroStart) : 0) || (currentSerieData.outroStart ? parseTime(currentSerieData.outroStart) : 0);
          
          initialStartTime = 0; // Nuovo episodio, inizia da 0
          
          const newUrl = new URL(window.location);
          newUrl.searchParams.set('serieId', CONFIG.serieId);
          newUrl.searchParams.set('stagioneIndex', seasonIdx.toString());
          newUrl.searchParams.set('episodioIndex', episodeIdx.toString());
          newUrl.searchParams.set('videoUrl', CONFIG.source);
          newUrl.searchParams.set('title', CONFIG.title);
          newUrl.searchParams.delete('startTime');
          if(CONFIG.contentType) newUrl.searchParams.set('contentType', CONFIG.contentType);
          if(CONFIG.returnTo && CONFIG.returnTo !== 'StreamRoot.html') newUrl.searchParams.set('returnTo', CONFIG.returnTo);
          window.history.pushState({ path: newUrl.href }, CONFIG.title, newUrl.href);

          loadSource(CONFIG.source);
      }

      // --- Navigation ---
      backToCatalogButton.addEventListener('click', () => { 
          console.log("[VideoPlayer] Torno al catalogo:", CONFIG.returnTo);
          window.location.href = CONFIG.returnTo; 
      });
      
      // --- Play/Pause & Video Event Handlers ---
      function togglePlayPause() { 
          if (video.readyState < video.HAVE_ENOUGH_DATA && video.networkState === video.NETWORK_LOADING && video.src) {
              console.log("[VideoPlayer] Video non ancora pronto, play/pausa ignorato."); return;
          }
          if (video.paused || video.ended) { 
              video.play().catch(e => console.warn("[VideoPlayer] Errore comando play:", e.message));
          } else { video.pause(); }
      }
      playPauseBtn.addEventListener('click', togglePlayPause); 
      video.addEventListener('click', togglePlayPause); 

      video.addEventListener('play', () => { 
        playPauseBtn.textContent = '‚è∏Ô∏è'; playPauseBtn.setAttribute('aria-label', 'Pausa'); playPauseBtn.title = 'Pausa';
        pauseOverlay.style.display = 'none'; 
        showControls(); 
        if (!hasAttemptedInitialFullscreen && isUserInteracted && !document.fullscreenElement) {
          console.log("[VideoPlayer] Tentativo autofullscreen su evento 'play'.");
          enterFullscreen().catch(err => console.warn("[VideoPlayer] Autofullscreen non riuscito:", err.message));
          hasAttemptedInitialFullscreen = true; 
        }
      });

      video.addEventListener('pause', () => { 
        playPauseBtn.textContent = '‚ñ∂Ô∏è'; playPauseBtn.setAttribute('aria-label', 'Play'); playPauseBtn.title = 'Play';
        if (!isDraggingSeekBar) { 
          pauseOverlay.style.display = 'block'; 
          setTimeout(() => { if(video.paused) pauseOverlay.style.display = 'none'; }, 600);
        }
        showControls(); 
      });

      video.addEventListener('ended', () => { 
          console.log("[VideoPlayer] Video terminato.");
          if (!isFilmSimple && currentSerieData) {
              let { stagioneIndex: currentSIdx, episodioIndex: currentEIdx } = CONFIG;
              let nextSIdx = currentSIdx, nextEIdx = currentEIdx + 1;

              if (currentSerieData.seasons[currentSIdx] && currentSerieData.seasons[currentSIdx].episodes[nextEIdx]) {
                  console.log("[VideoPlayer] Passaggio automatico al prossimo episodio nella stessa stagione.");
                  playEpisode(nextSIdx, nextEIdx);
              } else {
                  nextSIdx = currentSIdx + 1; nextEIdx = 0;
                  if (currentSerieData.seasons[nextSIdx] && currentSerieData.seasons[nextSIdx].episodes[nextEIdx]) {
                      console.log("[VideoPlayer] Passaggio automatico al primo episodio della prossima stagione.");
                      playEpisode(nextSIdx, nextEIdx);
                  } else {
                      console.log("[VideoPlayer] Fine serie o stagione.");
                  }
              }
          } else { playPauseBtn.textContent = '‚ñ∂Ô∏è'; }
      });

      // --- Fullscreen ---
      function enterFullscreen() { /* ... (invariato) ... */ }
      function exitFullscreen() { /* ... (invariato) ... */ }
      fullscreenBtn.addEventListener('click', () => {  /* ... (invariato) ... */ });
      const fullscreenEvents = ['fullscreenchange', 'webkitfullscreenchange', 'msfullscreenchange'];
      fullscreenEvents.forEach(event => document.addEventListener(event, () => { /* ... (invariato) ... */ }));
      video.addEventListener('dblclick', () => { /* ... (invariato) ... */ });
      
      // --- Volume & Speed ---
      volumeSlider.addEventListener('input', () => { 
          video.volume = parseFloat(volumeSlider.value);
          video.muted = video.volume === 0;
      });
      video.addEventListener('volumechange', () => { /* ... (invariato, ma verificato che aggiorni slider e icona) ... */ });
      volumeIcon.addEventListener('click', () => { 
          video.muted = !video.muted;
          if (!video.muted && video.volume === 0) video.volume = 0.5; 
      });
      speedSelector.addEventListener('change', () => video.playbackRate = parseFloat(speedSelector.value));

      // --- Progress Bar & Time Update ---
      function updateTimeDisplay() { /* ... (invariato) ... */ }
      function updateProgressBar() { /* ... (invariato) ... */ }
      function updateBufferedBar() { /* ... (invariato) ... */ }

      video.addEventListener('loadedmetadata', () => {
          console.log("[VideoPlayer] Metadati caricati. Durata:", video.duration, "ReadyState:", video.readyState);
          updateTimeDisplay(); updateProgressBar(); updateBufferedBar();
          if (previewVideo.src !== video.src && !video.src.includes('.m3u8')) previewVideo.src = video.src;
          
          if (initialStartTime > 0 && video.currentTime < 1 && video.duration > initialStartTime) { 
              console.log("[VideoPlayer] Imposto tempo iniziale a:", initialStartTime);
              video.currentTime = initialStartTime; 
              initialStartTime = 0; 
          }
          // **MODIFICA**: Chiamare setupAndPlay qui per MP4 se l'utente ha interagito
          if (!video.src.includes('.m3u8') && isUserInteracted) {
            console.log("[VideoPlayer] loadedmetadata per MP4, chiamo setupAndPlay() perch√© isUserInteracted=true");
            setupAndPlay();
          }
      }); 
      video.addEventListener('timeupdate', () => { /* ... (invariato, include skip intro/outro) ... */ }); 
      video.addEventListener('progress', updateBufferedBar); 
      video.addEventListener('durationchange', () => { /* ... (invariato) ... */ });

      // --- Seek Bar Logic ---
      function seek(event) { /* ... (invariato) ... */ }
      progressBar.addEventListener('click', seek);
      progressHandle.addEventListener('mousedown', (e) => { /* ... (invariato) ... */ });
      function handleDocumentMouseMove(e) { /* ... (invariato) ... */ }
      function handleDocumentMouseUp() { /* ... (invariato) ... */ }

      // --- Preview Thumbnail & Tooltip ---
      progressBar.addEventListener('mousemove', e => { /* ... (invariato) ... */ });
      progressBar.addEventListener('mouseout', () => { /* ... (invariato) ... */ });

      // --- Controls Visibility ---
      function showControls() { /* ... (invariato) ... */ }
      playerContainer.addEventListener('mousemove', showControls); 
      playerContainer.addEventListener('mouseenter', showControls);
      playerContainer.addEventListener('focusin', showControls); 
      playerContainer.addEventListener('mouseleave', () => { /* ... (invariato) ... */ });
      controls.addEventListener('mouseenter', () => clearTimeout(hideControlsTimeout));
      controls.addEventListener('mouseleave', () => { if (!video.paused) showControls(); });
      
      // --- Video Source Loading ---
      // ** MODIFICA IMPORTANTE IN setupAndPlay e chiamate **
      const setupAndPlay = () => {
          console.log("[VideoPlayer] Eseguo setupAndPlay(). ReadyState:", video.readyState);
          // Questa funzione ora si aspetta che volume/velocit√† siano gi√† impostati
          const playPromise = video.play();
          if (playPromise !== undefined) {
              playPromise.then(() => {
                  console.log("[VideoPlayer] Play avviato con successo tramite setupAndPlay.");
              }).catch(error => {
                  if (error.name === 'NotAllowedError') { 
                      console.warn('[VideoPlayer] Autoplay bloccato. L\'utente dovr√† cliccare play.'); 
                      playPauseBtn.textContent = '‚ñ∂Ô∏è'; playPauseBtn.setAttribute('aria-label', 'Play'); playPauseBtn.title = 'Play';
                  } else { 
                      console.error('[VideoPlayer] Errore durante il tentativo di play:', error.message); 
                      playPauseBtn.textContent = '‚ñ∂Ô∏è'; playPauseBtn.setAttribute('aria-label', 'Play'); playPauseBtn.title = 'Play';
                  }
              });
          } else {
            console.warn("[VideoPlayer] video.play() non ha restituito una Promise. Potrebbe essere gi√† in esecuzione o non supportato in questo contesto.");
          }
      };

      function loadSource(src) { 
          console.log("[VideoPlayer] loadSource chiamato con src:", src);
          if (!src) { 
              console.error("[VideoPlayer] Nessuna sorgente video fornita."); 
              timeDisplay.textContent = 'Errore / No Source'; return; 
          } 
          
          video.poster = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; 
          hasAttemptedInitialFullscreen = false; // **MODIFICA**: Resetta per ogni nuova sorgente
          
          if (hlsInstance) { hlsInstance.destroy(); hlsInstance = null; } 

          // **MODIFICA**: Ri-applicare volume e velocit√† prima di caricare la nuova sorgente
          video.volume = parseFloat(volumeSlider.value);
          video.muted = (parseFloat(volumeSlider.value) === 0); // Se il volume slider √® 0, muta. Altrimenti, non mutare.
                                                              // L'utente pu√≤ sempre usare l'icona per mutare/smutare.
          video.playbackRate = parseFloat(speedSelector.value);
          console.log(`[VideoPlayer] Stato pre-caricamento: Volume=${video.volume}, Muted=${video.muted}, Rate=${video.playbackRate}`);
          
          if (src.includes('.m3u8')) { 
              if (Hls.isSupported()) { 
                  console.log("[VideoPlayer] Caricamento HLS stream...");
                  hlsInstance = new Hls({ /* ... config ... */ }); 
                  hlsInstance.loadSource(src); 
                  hlsInstance.attachMedia(video); 
                  hlsInstance.on(Hls.Events.MANIFEST_PARSED, (event, data) => { 
                      console.log("[VideoPlayer] HLS Manifest Parsed."); 
                      // **MODIFICA**: Chiama sempre setupAndPlay, NotAllowedError gestir√† il blocco autoplay
                      if (isUserInteracted) { // Solo se l'utente ha interagito almeno una volta con la pagina
                        console.log("[VideoPlayer] MANIFEST_PARSED, chiamo setupAndPlay() perch√© isUserInteracted=true");
                        setupAndPlay();
                      } else {
                        console.log("[VideoPlayer] MANIFEST_PARSED, autoplay non tentato perch√© isUserInteracted=false");
                      }
                  }); 
                  hlsInstance.on(Hls.Events.ERROR, (event, data) => { /* ... (invariato) ... */ });
                  if (previewVideo.canPlayType('application/vnd.apple.mpegurl')) { previewVideo.src = src; } 
                  // else if (Hls.isSupported()) { /* ... preview HLS con altra istanza ... */ }
              } else if (video.canPlayType('application/vnd.apple.mpegurl')) { 
                  console.log("[VideoPlayer] Caricamento HLS stream (nativo).");
                  video.src = src; previewVideo.src = src; 
                  // L'evento 'loadedmetadata' per MP4/nativo HLS gestir√† la chiamata a setupAndPlay
              } else { 
                  console.error('[VideoPlayer] HLS non supportato.'); alert('HLS non supportato.'); 
              }
          } else { // MP4 o altri formati diretti
              console.log("[VideoPlayer] Caricamento video diretto (MP4 o altro).");
              video.src = src; 
              if (previewVideo.src !== src) previewVideo.src = src; 
              // L'evento 'loadedmetadata' gestir√† la chiamata a setupAndPlay se isUserInteracted √® true
          } 
          
          video.onerror = (e) => { /* ... (invariato) ... */ };
      }
      
      // --- INITIALIZATION ---
      console.log("[VideoPlayer] Inizializzazione player...");
      loadSerieDataFromStorage(); 
      showControls(); 
      video.volume = parseFloat(volumeSlider.value); // Impostazione iniziale
      video.muted = (parseFloat(volumeSlider.value) === 0);
      video.playbackRate = parseFloat(speedSelector.value); // Impostazione iniziale
      updateTimeDisplay(); 
      
      if (CONFIG.source) { 
        console.log("[VideoPlayer] Caricamento sorgente video iniziale:", CONFIG.source);
        loadSource(CONFIG.source); 
      } else { 
        console.warn("[VideoPlayer] Nessuna sorgente video iniziale specificata."); 
        if (currentSerieData && currentSerieData.seasons && currentSerieData.seasons.length > 0 &&
            !isNaN(CONFIG.stagioneIndex) && !isNaN(CONFIG.episodioIndex) &&
            currentSerieData.seasons[CONFIG.stagioneIndex] && currentSerieData.seasons[CONFIG.stagioneIndex].episodes[CONFIG.episodioIndex]) {
            console.log("[VideoPlayer] Tentativo di caricare l'episodio specificato da CONFIG.");
            playEpisode(CONFIG.stagioneIndex, CONFIG.episodioIndex);
        } else if (!isFilmSimple && currentSerieData && episodeSelectorGroup.style.display === 'flex') {
            timeDisplay.textContent = 'Seleziona Episodio';
        } else if (isFilmSimple) {
           alert("Nessun video da caricare. Specificare 'videoUrl'."); timeDisplay.textContent = 'Nessun Video';
        } else {
           alert("Dati serie non trovati o corrotti e nessuna sorgente specificata."); timeDisplay.textContent = 'Errore Dati';
        }
      }

    })(); 
  </script>
</body>
</html>
