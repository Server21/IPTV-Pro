<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Player Universale</title>
  <link rel="icon" href="data:,">
  <style>
    body { margin: 0; background: #121212; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #fff; }
    .player-container { position: relative; width: 80%; max-width: 900px; background: #000; border-radius: 12px; overflow: hidden; box-shadow: 0 8px 32px rgba(0,0,0,0.5); }
    .player-container.fullscreen { border-radius: 0; width: 100% !important; height: 100% !important; max-width: none !important; } /* Stili fullscreen */
    video { width: 100%; height: 100%; display: block; background: #000; cursor: pointer; object-fit: contain; } /* object-fit: contain per fullscreen */
    .pause-overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 64px; color: rgba(255,255,255,0.8); display: none; animation: fade 0.5s ease-in-out; pointer-events: none; }
    @keyframes fade { from { opacity: 0; } to { opacity: 1; } }
    .controls { position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.7); padding: 8px 12px; display: flex; flex-wrap: wrap; align-items: center; gap: 10px; opacity: 1; transition: opacity 0.3s ease; z-index: 2147483647; }
    .controls.hidden { opacity: 0; pointer-events: none; } /* pointer-events: none quando nascosto */
    .control-button { background: none; border: none; color: #fff; font-size: 20px; cursor: pointer; padding: 4px 8px; border-radius: 4px; display: flex; align-items: center; justify-content: center; min-width: 32px; height: 32px; }
    .control-button:hover { background-color: rgba(255,255,255,0.1); }
    .progress-bar-container { display: flex; align-items: center; width: 100%; order: 1; margin-bottom: 5px; /* Spazio sotto la barra */ }
    span#time-display { color: #fff; font-size: 0.9em; margin-right: 10px; }
    .progress-bar { position: relative; flex-grow: 1; height: 8px; background: #444; cursor: pointer; border-radius: 4px; }
    .progress-filled { width: 0; height: 100%; background: #e50914; border-radius: 4px; transition: width 0.1s linear; }
    .progress-buffered { position: absolute; top: 0; left: 0; width: 0; height: 100%; background: rgba(255,255,255,0.3); border-radius: 4px; opacity: 0.7; z-index: 1; }
    .progress-handle { position: absolute; top: 50%; left: 0; width: 14px; height: 14px; background: #e50914; border: 2px solid #fff; border-radius: 50%; transform: translate(-50%, -50%); cursor: pointer; opacity: 0; transition: opacity 0.2s ease, transform 0.2s ease; z-index: 3; }
    .progress-bar:hover .progress-handle { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
    .preview-thumb { position: absolute; bottom: 100%; left: 0; width: 160px; height: 90px; margin-bottom: 8px; background: #000; border: 2px solid #e50914; display: none; pointer-events: none; border-radius: 4px; overflow: hidden;}
    .preview-thumb video { width: 100%; height: 100%; object-fit: cover; }
    .tooltip { position: absolute; bottom: 100%; padding: 3px 6px; background: rgba(0,0,0,0.85); color: #fff; font-size:12px; border-radius:3px; transform: translateX(-50%); display: none; white-space:nowrap; margin-bottom: 8px; pointer-events: none;}
    
    .controls-main { display: flex; align-items: center; gap: 8px; order: 2; width: 100%; justify-content: space-between;}
    .controls-left, .controls-right { display: flex; align-items: center; gap: 8px; }
    .volume-control { display: flex; align-items: center; gap:4px; }
    select.player-select { background: #1f1f1f; color: #fff; border: 1px solid #444; border-radius:4px; padding:6px 8px; cursor: pointer; font-size: 0.9em; max-width: 180px; } 
    #nextEpisodeButton, #backToCatalogButton { padding: 6px 12px; background-color: #333; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s;}
    #nextEpisodeButton { background-color: #e50914;}
    #nextEpisodeButton:hover { background-color: #f40612; }
    #backToCatalogButton:hover { background-color: #555; }
    .episode-selector-group { display: flex; gap: 8px; align-items: center;}
  </style>
</head>
<body>
  <script>
    // URL Params and CONFIG setup
    const urlParams = new URLSearchParams(window.location.search);
    const videoUrlFromQuery = urlParams.get('videoUrl');
    const startTimeFromQuery = urlParams.get('startTime'); 
    const skipIntroStartFromQuery = urlParams.get('skipIntroStart');
    const skipIntroEndFromQuery = urlParams.get('skipIntroEnd');
    const outroStartFromQuery = urlParams.get('outroStart');
    const serieIdFromQuery = urlParams.get('serieId'); 
    const stagioneIndexFromQuery = parseInt(urlParams.get('stagioneIndex'), 10);
    const episodioIndexFromQuery = parseInt(urlParams.get('episodioIndex'), 10);
    const contentTypeFromQuery = urlParams.get('contentType'); 
    const returnToFromQuery = urlParams.get('returnTo');
    const titleFromQuery = urlParams.get('title');

    const CONFIG = {
      source: videoUrlFromQuery || '', 
      startTime: startTimeFromQuery || '0:00',
      skipIntroStart: skipIntroStartFromQuery, 
      skipIntroEnd: skipIntroEndFromQuery,
      outroStart: outroStartFromQuery,
      serieId: serieIdFromQuery,
      stagioneIndex: isNaN(stagioneIndexFromQuery) ? -1 : stagioneIndexFromQuery,
      episodioIndex: isNaN(episodioIndexFromQuery) ? -1 : episodioIndexFromQuery,
      contentType: contentTypeFromQuery,
      title: titleFromQuery,
      returnTo: returnToFromQuery || 'StreamRoot.html' // Default to StreamRoot.html
    };
    console.log("Player.html - CONFIG iniziale:", JSON.parse(JSON.stringify(CONFIG)));

    function parseTime(val){
        if(typeof val === 'string' && val.includes(':')){
            const parts = val.split(':');
            const m = parseInt(parts[0], 10) || 0;
            const s = parseInt(parts[1], 10) || 0;
            return m * 60 + s;
        } else if (typeof val === 'string' && !isNaN(parseFloat(val))) { return parseFloat(val); }
        else if (typeof val === 'number') { return val; }
        return 0;
    }
    
    let isFilmSimple = !CONFIG.contentType || CONFIG.contentType === 'film' || !CONFIG.serieId; // Consider film if no serieId
    let startTime=parseTime(CONFIG.startTime);
    let skipIntroStart = !isFilmSimple && CONFIG.skipIntroStart ? parseTime(CONFIG.skipIntroStart) : 0;
    let skipIntroEnd = !isFilmSimple && CONFIG.skipIntroEnd ? parseTime(CONFIG.skipIntroEnd) : 0;
    let outroStart = !isFilmSimple && CONFIG.outroStart ? parseTime(CONFIG.outroStart) : 0;

    let currentSerieData = null; 

    function isInternalResource(url) { /* Non usata per fullscreen, mantenuta per eventuale altra logica */
        if (!url) return false;
        return !url.toLowerCase().startsWith('http://') && !url.toLowerCase().startsWith('https://');
    }
  </script>

  <div class="player-container" id="playerContainer">
    <video id="video" playsinline autoplay poster="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"></video> 
    <div class="pause-overlay" id="pauseOverlay">‚è∏Ô∏è</div>
    <div class="controls" id="controls">
      <div class="progress-bar-container">
        <span id="time-display">00:00 / 00:00</span>
        <div class="progress-bar" id="progress-bar">
          <div class="progress-buffered" id="progress-buffered"></div>
          <div class="progress-filled" id="progress-filled"></div>
          <div class="progress-handle" id="progress-handle"></div>
          <div class="preview-thumb" id="preview-thumb"><video muted></video></div>
          <div class="tooltip" id="tooltip">00:00</div>
        </div>
      </div>
      
      <div class="controls-main">
        <div class="controls-left">
            <button class="control-button" id="playPauseBtn" title="Play/Pausa">‚ñ∂Ô∏è</button>
            <button class="control-button" id="backToCatalogButton" title="Torna al Catalogo">‚Üê</button> 
            <div id="episodeSelectorGroup" class="episode-selector-group" style="display: none;">
              <select id="seasonSelector" class="player-select" title="Seleziona Stagione"></select>
              <select id="episodeSelector" class="player-select" title="Seleziona Episodio"></select>
            </div>
        </div>
        <div class="controls-right">
            <button class="control-button" id="nextEpisodeButton" style="display:none;">Prossimo</button> 
            <div class="volume-control">
              <span id="volumeIcon" class="control-button" style="cursor:pointer;">üîä</span>
              <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1">
            </div>
            <select id="speed-selector" title="Velocit√†" class="player-select">
              <option value="0.5">0.5x</option><option value="0.75">0.75x</option>
              <option value="1" selected>1x</option><option value="1.25">1.25x</option>
              <option value="1.5">1.5x</option><option value="2">2x</option>
            </select>
            <button class="control-button" id="fullscreenBtn" title="Schermo Intero">‚õ∂</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script>
    const playerContainer=document.getElementById('playerContainer'), 
          video=document.getElementById('video'), 
          pauseOverlay=document.getElementById('pauseOverlay'),
          controls=document.getElementById('controls'), 
          progressBar=document.getElementById('progress-bar'), 
          progressFilled=document.getElementById('progress-filled'),
          progressBuffered=document.getElementById('progress-buffered'), 
          progressHandle=document.getElementById('progress-handle'), 
          timeDisplay=document.getElementById('time-display'), 
          previewThumb=document.getElementById('preview-thumb'),
          previewVideo=previewThumb.querySelector('video'), 
          tooltip=document.getElementById('tooltip'), 
          speedSelector=document.getElementById('speed-selector'), 
          volumeSlider=document.getElementById('volumeSlider'), 
          volumeIcon = document.getElementById('volumeIcon'), 
          playPauseBtn=document.getElementById('playPauseBtn'), 
          nextEpisodeButton = document.getElementById('nextEpisodeButton'), 
          backToCatalogButton = document.getElementById('backToCatalogButton'),
          fullscreenBtn=document.getElementById('fullscreenBtn'),
          episodeSelectorGroup = document.getElementById('episodeSelectorGroup'),
          seasonSelector = document.getElementById('seasonSelector'),
          episodeSelector = document.getElementById('episodeSelector');

    let isDragging = false, hideControlsTimeout, hlsInstance = null, hasTriggeredNextEpisode = false, hasAttemptedInitialFullscreen = false;

    function loadSerieDataFromStorage() {
        console.log("Player.html - Tentativo caricamento dati serie da localStorage per serieId:", CONFIG.serieId);
        if (CONFIG.serieId && (CONFIG.contentType === 'anime' || CONFIG.contentType === 'series_tv')) {
            const storedData = localStorage.getItem(`serieData_${CONFIG.serieId}`);
            console.log("Player.html - Dati grezzi da localStorage:", storedData ? storedData.substring(0,100) + "..." : "Nessun dato");
            if (storedData) {
                try {
                    currentSerieData = JSON.parse(storedData);
                    isFilmSimple = false; 
                    console.log("Player.html - Dati serie caricati e parsati:", currentSerieData);
                    populateSeasonSelector();
                } catch (e) {
                    console.error("Player.html - Errore parsing dati serie da localStorage:", e);
                    currentSerieData = null; isFilmSimple = true; 
                }
            } else {
                console.warn(`Player.html - Nessun dato serie trovato in localStorage per serieId: ${CONFIG.serieId}. I selettori non funzioneranno.`);
                isFilmSimple = true; 
            }
        } else {
            console.log("Player.html - Nessun serieId fornito o contentType √® film. Considerato film semplice.");
            isFilmSimple = true; 
        }
        episodeSelectorGroup.style.display = (!isFilmSimple && currentSerieData) ? 'flex' : 'none';
        nextEpisodeButton.style.display = (!isFilmSimple && currentSerieData) ? 'inline-flex' : 'none';
        backToCatalogButton.style.display = 'inline-flex'; // Sempre visibile
        console.log("Player.html - Visibilit√† selettori:", episodeSelectorGroup.style.display, "Pulsante Prossimo:", nextEpisodeButton.style.display);
    }
    
    function populateSeasonSelector() {
        if (!currentSerieData || !currentSerieData.seasons || isFilmSimple) {
            console.log("Player.html - populateSeasonSelector: Dati insufficienti o film.");
            return;
        }
        seasonSelector.innerHTML = '';
        currentSerieData.seasons.forEach((season, index) => {
            const option = document.createElement('option');
            option.value = index; // Usa l'indice dell'array come value
            option.textContent = season.name || `Stagione ${season.season_number}`;
            if (index === CONFIG.stagioneIndex) {
                option.selected = true;
            }
            seasonSelector.appendChild(option);
        });
        console.log("Player.html - Selettore stagioni popolato. Stagione corrente selezionata:", CONFIG.stagioneIndex);
        populateEpisodeSelector(CONFIG.stagioneIndex);
    }

    function populateEpisodeSelector(seasonIdx) {
        if (!currentSerieData || !currentSerieData.seasons || !currentSerieData.seasons[seasonIdx] || !currentSerieData.seasons[seasonIdx].episodes || isFilmSimple) {
            console.log("Player.html - populateEpisodeSelector: Dati stagione/episodi insufficienti o film. seasonIdx:", seasonIdx);
             episodeSelector.innerHTML = '<option>N/A</option>'; return;
        }
        episodeSelector.innerHTML = '';
        const episodes = currentSerieData.seasons[seasonIdx].episodes;
        episodes.forEach((ep, index) => { // index √® l'indice dell'array 0-based
            const option = document.createElement('option');
            option.value = index; 
            option.textContent = ep.name || `Episodio ${ep.episode_number}`;
            // Seleziona l'episodio corrente se la stagione corrente √® selezionata
            if (index === CONFIG.episodioIndex && parseInt(seasonSelector.value, 10) === CONFIG.stagioneIndex) {
                option.selected = true;
            }
            episodeSelector.appendChild(option);
        });
        console.log("Player.html - Selettore episodi popolato per stagioneIdx:", seasonIdx, "Episodio corrente selezionato:", CONFIG.episodioIndex);
    }

    seasonSelector.addEventListener('change', (e) => {
        const newSeasonIndex = parseInt(e.target.value, 10);
        console.log("Player.html - Cambio stagione selezionata a index:", newSeasonIndex);
        populateEpisodeSelector(newSeasonIndex);
        playEpisode(newSeasonIndex, 0); // Carica il primo episodio della nuova stagione
    });

    episodeSelector.addEventListener('change', (e) => {
        const newSeasonIndex = parseInt(seasonSelector.value, 10);
        const newEpisodeIndex = parseInt(e.target.value, 10);
        console.log("Player.html - Cambio episodio selezionato a seasonIdx:", newSeasonIndex, "episodeIdx:", newEpisodeIndex);
        playEpisode(newSeasonIndex, newEpisodeIndex);
    });

    function playEpisode(seasonIdx, episodeIdx) {
        console.log(`Player.html - Tentativo playEpisode: Stagione ${seasonIdx}, Episodio ${episodeIdx}`);
        if (!currentSerieData || !currentSerieData.seasons[seasonIdx] || !currentSerieData.seasons[seasonIdx].episodes[episodeIdx]) {
            console.error("Player.html - Dati episodio non trovati per la selezione:", seasonIdx, episodeIdx);
            return;
        }
        const episode = currentSerieData.seasons[seasonIdx].episodes[episodeIdx];
        console.log("Player.html - Dati episodio da caricare:", episode);

        CONFIG.source = episode.file;
        CONFIG.stagioneIndex = seasonIdx;
        CONFIG.episodioIndex = episodeIdx;
        CONFIG.skipIntroStart = episode.skipIntroStart || '';
        CONFIG.skipIntroEnd = episode.skipIntroEnd || '';
        CONFIG.outroStart = episode.outroStart || '';
        
        startTime = 0; 
        skipIntroStart = parseTime(CONFIG.skipIntroStart);
        skipIntroEnd = parseTime(CONFIG.skipIntroEnd);
        outroStart = parseTime(CONFIG.outroStart);

        const newParams = new URLSearchParams(window.location.search);
        newParams.set('videoUrl', episode.file);
        newParams.set('stagioneIndex', seasonIdx.toString());
        newParams.set('episodeIndex', episodeIdx.toString());
        if(episode.skipIntroStart) newParams.set('skipIntroStart', episode.skipIntroStart); else newParams.delete('skipIntroStart');
        if(episode.skipIntroEnd) newParams.set('skipIntroEnd', episode.skipIntroEnd); else newParams.delete('skipIntroEnd');
        if(episode.outroStart) newParams.set('outroStart', episode.outroStart); else newParams.delete('outroStart');
        // Non modificare title, serieId, contentType, returnTo perch√© sono relativi alla serie/film generale
        history.pushState(null, '', `${window.location.pathname}?${newParams.toString()}`);
        console.log("Player.html - URL aggiornato (history.pushState). Nuovi parametri:", newParams.toString());
        
        loadSource(episode.file);
    }

    function triggerNextEpisode() {
        if (hasTriggeredNextEpisode) return; 
        console.log("Player.html - Tentativo di triggerNextEpisode. CONFIG:", JSON.parse(JSON.stringify(CONFIG))); 
        const returnToPlayer = CONFIG.returnTo && CONFIG.returnTo.startsWith('/') ? 
                               window.location.origin + CONFIG.returnTo : CONFIG.returnTo;

        if (CONFIG.serieId && CONFIG.stagioneIndex !== -1 && CONFIG.episodioIndex !== -1 && CONFIG.contentType && CONFIG.contentType !== 'film') {
            hasTriggeredNextEpisode = true; 
            let streamRootUrl = `StreamRoot.html#playNext?serieId=${encodeURIComponent(CONFIG.serieId)}&stagioneIndex=${CONFIG.stagioneIndex}&episodioIndex=${CONFIG.episodioIndex}&contentType=${CONFIG.contentType}&returnTo=${encodeURIComponent(returnToPlayer || 'StreamRoot.html')}`;
            console.log("Player.html - Reindirizzamento a:", streamRootUrl);
            window.location.href = streamRootUrl;
        } else {
            console.warn("Player.html - triggerNextEpisode: Condizioni non soddisfatte o dati mancanti. SerieID:", CONFIG.serieId, "StagioneIdx:", CONFIG.stagioneIndex, "EpisodioIdx:", CONFIG.episodioIndex);
        }
    }
    nextEpisodeButton.addEventListener('click', triggerNextEpisode);
    backToCatalogButton.addEventListener('click', () => {
        const returnUrl = decodeURIComponent(CONFIG.returnTo);
        console.log("Player.html - Torno al catalogo:", returnUrl);
        window.location.href = returnUrl; 
    });

    function togglePlayPause() { /* ... (invariato, ma con log se serve) ... */ }
    playPauseBtn.addEventListener('click', togglePlayPause); 
    video.addEventListener('click', togglePlayPause);

    video.addEventListener('play', () => { 
      playPauseBtn.textContent = '‚è∏Ô∏è'; 
      pauseOverlay.style.display = 'none'; 
      showControls(); 
      // Rimosso isInternalResource per tentare sempre il fullscreen (soggetto a policy browser)
      if (!hasAttemptedInitialFullscreen && !document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
        const fsPromise = playerContainer.requestFullscreen ? playerContainer.requestFullscreen() :
                          playerContainer.webkitRequestFullscreen ? playerContainer.webkitRequestFullscreen() :
                          playerContainer.msRequestFullscreen ? playerContainer.msRequestFullscreen() :
                          Promise.reject(new Error("Fullscreen API not supported"));
        fsPromise.then(()=> console.log("Player.html - Fullscreen richiesto.")).catch(err => console.warn("Player.html - Autofullscreen non riuscito:", err.message));
        hasAttemptedInitialFullscreen = true; 
      }
    });
    video.addEventListener('pause', () => { /* ... (invariato) ... */ });
    video.addEventListener('ended', () => { 
        playPauseBtn.textContent = '‚ñ∂Ô∏è'; showControls(); 
        if (!isFilmSimple && currentSerieData) { nextEpisodeButton.style.display = 'inline-flex'; } 
        triggerNextEpisode(); 
    });
    function updateBufferedBar() { /* ... (invariato) ... */ }
    video.addEventListener('progress', updateBufferedBar); video.addEventListener('loadedmetadata', updateBufferedBar); video.addEventListener('canplaythrough', updateBufferedBar);
    function enterFullscreen() { /* ... (invariato) ... */ }
    function exitFullscreen() { /* ... (invariato) ... */ }
    fullscreenBtn.addEventListener('click', () => {  if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) enterFullscreen(); else exitFullscreen(); });
    document.addEventListener('fullscreenchange', () => { playerContainer.classList.toggle('fullscreen', !!document.fullscreenElement); showControls(); });
    document.addEventListener('webkitfullscreenchange', () => { playerContainer.classList.toggle('fullscreen', !!document.webkitFullscreenElement); showControls(); });
    document.addEventListener('msfullscreenchange', () => { playerContainer.classList.toggle('fullscreen', !!document.msFullscreenElement); showControls(); });
    video.addEventListener('dblclick', () => { if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) enterFullscreen(); else exitFullscreen(); });
    volumeSlider.addEventListener('input', () => { /* ... (invariato) ... */ });
    video.addEventListener('volumechange', () => { /* ... (invariato) ... */ });
    volumeIcon.addEventListener('click', () => { /* ... (invariato) ... */ });
    speedSelector.addEventListener('change', () => video.playbackRate = parseFloat(speedSelector.value));
    
    function loadSource(src) { 
        console.log("Player.html - loadSource chiamato con src:", src);
        if (!src) { console.error("Player.html - Nessuna sorgente video fornita a loadSource."); alert("Nessun video da caricare."); return; } 
        video.poster = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
        hasTriggeredNextEpisode = false; 
        if (hlsInstance) { hlsInstance.destroy(); hlsInstance = null; } 
        const setupAndPlayVideo = (readyPromise) => {
            readyPromise.then(() => {
                if (startTime > 0 && startTime < video.duration) { video.currentTime = startTime; startTime = 0; /* Resetta startTime dopo il primo uso */ }
                const playPromise = video.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        if (error.name === 'NotAllowedError') { console.warn('Player.html - Autoplay bloccato.'); playPauseBtn.textContent = '‚ñ∂Ô∏è';
                        } else { console.error('Player.html - Errore autoplay:', error.message); playPauseBtn.textContent = '‚ñ∂Ô∏è'; }
                    });
                }
            }).catch(e => { console.error("Player.html - Errore setup video (es. caricamento metadati):", e.message); playPauseBtn.textContent = '‚ñ∂Ô∏è';});
        };
        if (src.includes('.m3u8')) { /* ... (logica HLS invariata) ... */ }
        else { /* ... (logica MP4 invariata) ... */ }
        // Assicurati che gli handler onloadedmetadata e onerror siano impostati qui
        video.onloadedmetadata = () => { console.log("Player.html - Metadati video caricati."); updateTime(); updateBufferedBar(); }; 
        video.onerror = (e) => { console.error("Player.html - Errore elemento video:", e); playPauseBtn.textContent = '‚ñ∂Ô∏è';};
    }
    function formatTime(s) { /* ... (invariato) ... */ }
    function updateTime() { /* ... (invariato) ... */ }
    video.addEventListener('loadedmetadata', updateTime); 
    video.addEventListener('timeupdate', updateTime); 
    function showControls() { /* ... (invariato) ... */ }
    playerContainer.addEventListener('mousemove', showControls); playerContainer.addEventListener('focusin', showControls); playerContainer.addEventListener('mouseleave', () => { /* ... (invariato) ... */ });
    controls.addEventListener('mouseenter', () => clearTimeout(hideControlsTimeout)); controls.addEventListener('mouseleave', () => { /* ... (invariato) ... */ });
    function seek(e) { /* ... (invariato) ... */ }
    progressBar.addEventListener('click', seek);
    progressHandle.addEventListener('mousedown', (e) => { /* ... (invariato) ... */ });
    document.addEventListener('mousemove', (e) => { /* ... (invariato) ... */ });
    document.addEventListener('mouseup', () => { if (isDragging) { /* ... (invariato) ... */ }});
    progressBar.addEventListener('mousemove', e => { /* ... (invariato) ... */ });
    progressBar.addEventListener('mouseout', () => { if (!isDragging) { /* ... (invariato) ... */ }});
    
    video.addEventListener('timeupdate', () => {
      if (!isFinite(video.duration) || video.readyState < video.HAVE_METADATA) return;
      if (!isDragging) { 
        const progressPercent = (video.currentTime / video.duration) * 100;
        progressFilled.style.width = `${progressPercent}%`; progressHandle.style.left = `${progressPercent}%`;
      }
      updateTime(); updateBufferedBar();
      if (!isFilmSimple && skipIntroStart > 0 && skipIntroEnd > skipIntroStart && video.currentTime >= skipIntroStart && video.currentTime < skipIntroEnd) { 
        video.currentTime = skipIntroEnd; 
      }
      if (!isFilmSimple && outroStart > 0 && video.currentTime >= outroStart && video.currentTime < video.duration - 0.5 && !video.paused && !hasTriggeredNextEpisode) { 
        video.pause(); 
        if (currentSerieData) { nextEpisodeButton.style.display = 'inline-flex'; }
      }
    });
    
    // INIZIALIZZAZIONE
    console.log("Player.html - Inizializzazione player...");
    loadSerieDataFromStorage(); 
    showControls(); 
    video.volume = parseFloat(volumeSlider.value); 
    video.playbackRate = parseFloat(speedSelector.value); 
    
    if (CONFIG.source) { 
      console.log("Player.html - Caricamento sorgente video iniziale:", CONFIG.source);
      loadSource(CONFIG.source); 
    } else { 
      console.warn("Player.html - Nessuna sorgente video iniziale (CONFIG.source vuoto)."); 
      if (currentSerieData && currentSerieData.seasons && currentSerieData.seasons.length > 0) {
          console.log("Player.html - Dati serie presenti, ma nessuna sorgente video iniziale. L'utente dovrebbe usare i selettori.");
      } else if (isFilmSimple) {
         alert("Nessun video da caricare. Specificare 'videoUrl' nei parametri URL."); 
      } else {
         alert("Dati della serie non trovati o corrotti e nessuna sorgente video specificata. Impossibile caricare.");
      }
    }
  </script>
</body>
</html>
