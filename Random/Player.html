<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Player Video Avanzato</title>
  <link rel="icon" href="data:,">
  <style>
    :root {
      --player-background: #000;
      --player-text-color: #e0e0e0;
      --player-highlight-color: #e50914; /* Rosso Netflix-like */
      --player-control-bar-bg: linear-gradient(to top, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.6) 60%, transparent 100%);
      --progress-bar-bg: rgba(255,255,255,0.2);
      --progress-filled-bg: var(--player-highlight-color);
      --progress-buffered-bg: rgba(255,255,255,0.4);
      --progress-handle-bg: var(--player-highlight-color);
      --progress-handle-border: #fff;
      --tooltip-bg: rgba(0,0,0,0.9);
      --select-bg: #2a2a2a;
      --select-border-color: #555;
      --button-bg-hover: rgba(255,255,255,0.2);
    }

    body { 
      margin: 0; 
      background: #0e0e0e; 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      height: 100vh; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
      color: var(--player-text-color); 
      overflow: hidden; 
    }
    .player-container { 
      position: relative; 
      width: 90%; 
      max-width: 1000px; 
      background: var(--player-background); 
      border-radius: 12px; 
      overflow: hidden; 
      box-shadow: 0 10px 40px rgba(0,0,0,0.7); 
      aspect-ratio: 16 / 9;
    }
    .player-container.fullscreen { 
      width: 100vw !important; 
      height: 100vh !important; 
      max-width: none !important; 
      border-radius: 0; 
      aspect-ratio: auto; 
    }
    video { 
      width: 100%; 
      height: 100%; 
      display: block; 
      background: var(--player-background); 
      cursor: pointer; 
      object-fit: contain; 
    }
    .pause-overlay { 
      position: absolute; 
      top: 50%; 
      left: 50%; 
      transform: translate(-50%, -50%); 
      font-size: 72px; 
      color: rgba(255,255,255,0.85); 
      display: none; 
      animation: fadeOverlay 0.5s ease-in-out; 
      pointer-events: none; 
      text-shadow: 0 0 15px rgba(0,0,0,0.5); 
    }
    @keyframes fadeOverlay { 
      from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); } 
      to { opacity: 1; transform: translate(-50%, -50%) scale(1); } 
    }
    .controls { 
      position: absolute; 
      bottom: 0; 
      left: 0; 
      right: 0; 
      background: var(--player-control-bar-bg); 
      padding: 10px 15px; 
      display: flex; 
      flex-direction: column; 
      gap: 8px; 
      opacity: 1; 
      transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out; 
      z-index: 2147483647; 
      transform: translateY(0%); 
    }
    .controls.hidden { 
      opacity: 0; 
      pointer-events: none; 
      transform: translateY(100%); 
    }
    .progress-bar-container { 
      display: flex; 
      align-items: center; 
      width: 100%; 
      order: 1; 
    }
    span#time-display { 
      color: var(--player-text-color); 
      font-size: 0.9em; 
      margin-right: 12px; 
      font-variant-numeric: tabular-nums; 
      min-width: 90px; /* Per evitare scatti nel layout */
      text-align: center;
    }
    .progress-bar { 
      position: relative; 
      flex-grow: 1; 
      height: 6px; 
      background: var(--progress-bar-bg); 
      cursor: pointer; 
      border-radius: 3px; 
      transition: height 0.2s ease; 
    }
    .progress-bar:hover { height: 10px; }
    .progress-filled { 
      width: 0; 
      height: 100%; 
      background: var(--progress-filled-bg); 
      border-radius: 3px; 
    }
    .progress-buffered { 
      position: absolute; 
      top: 0; 
      left: 0; 
      width: 0; 
      height: 100%; 
      background: var(--progress-buffered-bg); 
      border-radius: 3px; 
      z-index: -1; 
    }
    .progress-handle { 
      position: absolute; 
      top: 50%; 
      left: 0; 
      width: 14px; 
      height: 14px; 
      background: var(--progress-handle-bg); 
      border: 2px solid var(--progress-handle-border); 
      border-radius: 50%; 
      transform: translate(-50%, -50%) scale(0); 
      cursor: grabbing; 
      opacity: 0; 
      transition: opacity 0.2s ease, transform 0.2s ease; 
      z-index: 3; 
      box-shadow: 0 0 8px rgba(0,0,0,0.5); 
    }
    .progress-bar:hover .progress-handle, .progress-handle.dragging { 
      opacity: 1; 
      transform: translate(-50%, -50%) scale(1); 
    }
    .preview-thumb { 
      position: absolute; 
      bottom: calc(100% + 10px); 
      left: 0; 
      width: 160px; 
      height: 90px; 
      background: #111; 
      border: 2px solid var(--player-highlight-color); 
      display: none; 
      pointer-events: none; 
      border-radius: 4px; 
      overflow: hidden; 
      box-shadow: 0 0 15px rgba(0,0,0,0.5);
    }
    .preview-thumb video { 
      width: 100%; 
      height: 100%; 
      object-fit: cover; 
    }
    .tooltip { 
      position: absolute; 
      bottom: calc(100% + 10px); /* Stessa posizione della thumb se questa non c'√® */
      padding: 4px 8px; 
      background: var(--tooltip-bg); 
      color: #fff; 
      font-size:13px; 
      border-radius:3px; 
      transform: translateX(-50%); 
      display: none; 
      white-space:nowrap; 
      pointer-events: none; 
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
    }
    
    .controls-main { 
      display: flex; 
      align-items: center; 
      gap: 10px; 
      order: 2; 
      width: 100%; 
      justify-content: space-between; 
      padding-top: 5px; 
    }
    .controls-left, .controls-right { 
      display: flex; 
      align-items: center; 
      gap: 10px; 
    }
    .volume-control { 
      display: flex; 
      align-items: center; 
      gap:5px; 
    }
    .volume-control input[type=range] { 
      width: 70px; 
      cursor: pointer; 
      -webkit-appearance: none; 
      appearance: none; 
      background: transparent; 
    }
    .volume-control input[type=range]::-webkit-slider-runnable-track { 
      height: 5px; 
      background: var(--progress-bar-bg); 
      border-radius: 3px; 
    }
    .volume-control input[type=range]::-webkit-slider-thumb { 
      -webkit-appearance: none; 
      appearance: none; 
      margin-top: -4.5px; 
      width: 14px; 
      height: 14px; 
      background: var(--progress-handle-border); 
      border-radius: 50%; 
      border: 1px solid var(--player-highlight-color); 
    }
    .volume-control input[type=range]::-moz-range-track { 
      height: 5px; 
      background: var(--progress-bar-bg); 
      border-radius: 3px; 
    }
    .volume-control input[type=range]::-moz-range-thumb { 
      width: 12px; 
      height: 12px; 
      background: var(--progress-handle-border); 
      border-radius: 50%; 
      border: 1px solid var(--player-highlight-color); 
    }

    select.player-select { 
      background: var(--select-bg); 
      color: var(--player-text-color); 
      border: 1px solid var(--select-border-color); 
      border-radius:4px; 
      padding:7px 10px; 
      cursor: pointer; 
      font-size: 0.9em; 
      max-width: 200px; 
      transition: border-color 0.2s; 
    } 
    select.player-select:hover { border-color: var(--player-highlight-color); }
    #backToCatalogButton { 
      padding: 7px 14px; 
      background-color: rgba(255,255,255,0.1); 
      color: white; 
      border: none; 
      border-radius: 4px; 
      cursor: pointer; 
      font-size: 0.9em; 
      transition: background-color 0.2s;
    }
    #backToCatalogButton:hover { background-color: var(--button-bg-hover); }
    .episode-selector-group { 
      display: flex; 
      gap: 10px; 
      align-items: center;
    }
    .control-button { 
      background: none;
      border: none;
      color: var(--player-text-color);
      font-size: 1.5em; 
      padding: 5px;
      cursor: pointer;
      line-height: 1; 
      transition: transform 0.1s ease; 
    }
    .control-button:active { transform: scale(0.9); }
  </style>
</head>
<body>
  <div class="player-container" id="playerContainer">
    <video id="video" playsinline poster="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" preload="metadata"></video> 
    <div class="pause-overlay" id="pauseOverlay">‚è∏Ô∏è</div>
    <div class="controls" id="controls">
      <div class="progress-bar-container">
        <span id="time-display">00:00 / 00:00</span>
        <div class="progress-bar" id="progressBar">
          <div class="progress-buffered" id="progressBuffered"></div>
          <div class="progress-filled" id="progressFilled"></div>
          <div class="progress-handle" id="progressHandle"></div>
          <div class="preview-thumb" id="previewThumb"><video muted playsinline preload="metadata"></video></div>
          <div class="tooltip" id="tooltip">00:00</div>
        </div>
      </div>
      
      <div class="controls-main">
        <div class="controls-left">
            <button class="control-button" id="playPauseBtn" title="Play/Pausa" aria-label="Play">‚ñ∂Ô∏è</button>
            <button class="control-button" id="backToCatalogButton" title="Torna al Catalogo">‚Üê</button> 
            <div id="episodeSelectorGroup" class="episode-selector-group" style="display: none;">
              <select id="seasonSelector" class="player-select" title="Seleziona Stagione" aria-label="Seleziona Stagione"></select>
              <select id="episodeSelector" class="player-select" title="Seleziona Episodio" aria-label="Seleziona Episodio"></select>
            </div>
        </div>
        <div class="controls-right">
            <div class="volume-control">
              <span id="volumeIcon" class="control-button" style="cursor:pointer;" title="Muto/Audio" aria-label="Audio Attivo">üîä</span>
              <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1" title="Volume" aria-label="Regola Volume">
            </div>
            <select id="speedSelector" title="Velocit√†" class="player-select" aria-label="Seleziona Velocit√†">
              <option value="0.5">0.5x</option><option value="0.75">0.75x</option>
              <option value="1" selected>1x</option><option value="1.25">1.25x</option>
              <option value="1.5">1.5x</option><option value="2">2x</option>
            </select>
            <button class="control-button" id="fullscreenBtn" title="Schermo Intero" aria-label="Attiva Schermo Intero">‚õ∂</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script>
    (function() {
      'use strict';

      // --- Helper Functions ---
      function parseTime(timeString) {
          if (typeof timeString !== 'string') return 0;
          const parts = timeString.split(':').map(Number);
          let seconds = 0;
          if (parts.length === 3) { // HH:MM:SS
              seconds = (parts[0] * 3600) + (parts[1] * 60) + parts[2];
          } else if (parts.length === 2) { // MM:SS
              seconds = (parts[0] * 60) + parts[1];
          } else if (parts.length === 1) { // SS
              seconds = parts[0];
          }
          return isNaN(seconds) ? 0 : Math.max(0, seconds);
      }

      function formatTime(s) { 
          if (isNaN(s) || !isFinite(s) || s < 0) return '00:00'; 
          const hours = Math.floor(s / 3600);
          const m = Math.floor((s % 3600) / 60); 
          const sec = Math.floor(s % 60); 
          if (hours > 0) {
            return `${hours.toString()}:${m.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
          }
          return `${m.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`; 
      }

      // --- URL Params and CONFIG setup ---
      const urlParams = new URLSearchParams(window.location.search);
      const CONFIG = {
        source: urlParams.get('videoUrl') || '', 
        startTime: urlParams.get('startTime') || '0:00',
        skipIntroStart: urlParams.get('skipIntroStart'), 
        skipIntroEnd: urlParams.get('skipIntroEnd'),
        outroStart: urlParams.get('outroStart'),
        serieId: urlParams.get('serieId'), 
        stagioneIndex: parseInt(urlParams.get('stagioneIndex'), 10), 
        episodioIndex: parseInt(urlParams.get('episodioIndex'), 10), 
        contentType: urlParams.get('contentType'), 
        title: urlParams.get('title') || 'Video Player', 
        returnTo: urlParams.get('returnTo') || 'StreamRoot.html'
      };
      console.log("[VideoPlayer] CONFIG iniziale:", JSON.parse(JSON.stringify(CONFIG)));
      document.title = CONFIG.title; 

      let isFilmSimple = !CONFIG.contentType || CONFIG.contentType === 'film' || !CONFIG.serieId;
      let initialStartTime = parseTime(CONFIG.startTime); 
      let skipIntroStart = !isFilmSimple && CONFIG.skipIntroStart ? parseTime(CONFIG.skipIntroStart) : 0;
      let skipIntroEnd = !isFilmSimple && CONFIG.skipIntroEnd ? parseTime(CONFIG.skipIntroEnd) : 0;
      let outroStart = !isFilmSimple && CONFIG.outroStart ? parseTime(CONFIG.outroStart) : 0;
      let currentSerieData = null; 

      // --- DOM Element Constants ---
      const playerContainer = document.getElementById('playerContainer');
      const video = document.getElementById('video');
      const pauseOverlay = document.getElementById('pauseOverlay');
      const controls = document.getElementById('controls');
      const progressBar = document.getElementById('progressBar');
      const progressFilled = document.getElementById('progressFilled');
      const progressBuffered = document.getElementById('progressBuffered');
      const progressHandle = document.getElementById('progressHandle');
      const timeDisplay = document.getElementById('time-display');
      const previewThumb = document.getElementById('previewThumb');
      const previewVideo = previewThumb.querySelector('video');
      const tooltip = document.getElementById('tooltip');
      const speedSelector = document.getElementById('speedSelector');
      const volumeSlider = document.getElementById('volumeSlider');
      const volumeIcon = document.getElementById('volumeIcon');
      const playPauseBtn = document.getElementById('playPauseBtn');
      const backToCatalogButton = document.getElementById('backToCatalogButton');
      const fullscreenBtn = document.getElementById('fullscreenBtn');
      const episodeSelectorGroup = document.getElementById('episodeSelectorGroup');
      const seasonSelector = document.getElementById('seasonSelector');
      const episodeSelector = document.getElementById('episodeSelector');

      // --- State Variables ---
      let isDraggingSeekBar = false;
      let hideControlsTimeout;
      let hlsInstance = null;
      let hasAttemptedInitialFullscreen = false;
      let isUserInteracted = false; 

      // --- User Interaction Listener ---
      function userInteractionHandler() {
          if (isUserInteracted) return;
          isUserInteracted = true;
          document.removeEventListener('click', userInteractionHandler);
          document.removeEventListener('keydown', userInteractionHandler);
          document.removeEventListener('touchstart', userInteractionHandler);
          console.log("[VideoPlayer] Interazione utente rilevata.");

          // Se il video √® gi√† caricato e in pausa, tenta di avviarlo con setupAndPlay
          // (video.src !== window.location.href) √® un controllo per assicurarsi che video.src non sia l'URL della pagina (default)
          if (video.paused && video.readyState >= video.HAVE_METADATA && video.src && video.src !== window.location.href) {
              console.log("[VideoPlayer] UserInteraction: Video pronto e in pausa, chiamo setupAndPlay().");
              setupAndPlay();
          } else if (video.paused) {
            console.log("[VideoPlayer] UserInteraction: Video in pausa, ma non ancora pronto o senza sorgente valida. ReadyState:", video.readyState, "Src:", video.src);
          }
      }
      document.addEventListener('click', userInteractionHandler);
      document.addEventListener('keydown', userInteractionHandler);
      document.addEventListener('touchstart', userInteractionHandler);

      // --- Serie/Episode Data Logic --- 
      function loadSerieDataFromStorage() {
          console.log("[VideoPlayer] Tentativo caricamento dati serie da localStorage per serieId:", CONFIG.serieId);
          if (CONFIG.serieId && (CONFIG.contentType === 'anime' || CONFIG.contentType === 'series_tv')) {
              const storedData = localStorage.getItem(`serieData_${CONFIG.serieId}`);
              if (storedData) {
                  try {
                      currentSerieData = JSON.parse(storedData);
                      isFilmSimple = false; 
                      console.log("[VideoPlayer] Dati serie caricati e parsati:", currentSerieData);
                      populateSeasonSelector();
                  } catch (e) { 
                      console.error("[VideoPlayer] Errore parsing dati serie:", e); 
                      currentSerieData = null; isFilmSimple = true; 
                  }
              } else { 
                  console.warn(`[VideoPlayer] Nessun dato serie per ID: ${CONFIG.serieId}. Considerato come film.`); 
                  isFilmSimple = true; 
              }
          } else { isFilmSimple = true; }
          episodeSelectorGroup.style.display = (!isFilmSimple && currentSerieData) ? 'flex' : 'none';
          console.log("[VideoPlayer] Visibilit√† selettori episodi:", episodeSelectorGroup.style.display);
      }
      
      function populateSeasonSelector() {
          seasonSelector.innerHTML = ''; 
          if (!currentSerieData || !currentSerieData.seasons || currentSerieData.seasons.length === 0) {
              const defaultOption = new Option("Nessuna stagione", "");
              defaultOption.disabled = true; seasonSelector.add(defaultOption);
              populateEpisodeSelector(-1); return;
          }
          currentSerieData.seasons.forEach((season, index) => {
              const seasonName = season.name || season.title || `Stagione ${index + 1}`;
              const option = new Option(seasonName, index.toString());
              seasonSelector.add(option);
          });
          if (!isNaN(CONFIG.stagioneIndex) && CONFIG.stagioneIndex < currentSerieData.seasons.length && CONFIG.stagioneIndex >= 0) {
              seasonSelector.value = CONFIG.stagioneIndex.toString();
          } else if (currentSerieData.seasons.length > 0) {
              CONFIG.stagioneIndex = 0; seasonSelector.value = "0";
          }
          populateEpisodeSelector(CONFIG.stagioneIndex);
      }

      function populateEpisodeSelector(seasonIdx) {
          episodeSelector.innerHTML = ''; 
          if (isNaN(seasonIdx) || seasonIdx < 0 || !currentSerieData || !currentSerieData.seasons[seasonIdx] || !currentSerieData.seasons[seasonIdx].episodes || currentSerieData.seasons[seasonIdx].episodes.length === 0) {
              const defaultOption = new Option("Nessun episodio", "");
              defaultOption.disabled = true; episodeSelector.add(defaultOption); return;
          }
          const episodes = currentSerieData.seasons[seasonIdx].episodes;
          episodes.forEach((episode, index) => {
              const episodeTitle = episode.title || episode.name || `Episodio ${index + 1}`;
              const option = new Option(episodeTitle, index.toString());
              episodeSelector.add(option);
          });
          if (!isNaN(CONFIG.episodioIndex) && parseInt(seasonSelector.value, 10) === CONFIG.stagioneIndex && CONFIG.episodioIndex < episodes.length && CONFIG.episodioIndex >= 0) {
            episodeSelector.value = CONFIG.episodioIndex.toString();
          } else if (episodes.length > 0) {
             CONFIG.episodioIndex = 0; episodeSelector.value = "0";
          }
      }

      seasonSelector.addEventListener('change', (e) => {
          const newSeasonIndex = parseInt(e.target.value, 10);
          if (!isNaN(newSeasonIndex)) {
              CONFIG.stagioneIndex = newSeasonIndex;
              CONFIG.episodioIndex = 0; 
              populateEpisodeSelector(newSeasonIndex);
              if (episodeSelector.options.length > 0 && !episodeSelector.options[0].disabled) {
                  playEpisode(CONFIG.stagioneIndex, CONFIG.episodioIndex);
              }
          }
      });

      episodeSelector.addEventListener('change', (e) => {
          const newEpisodeIndex = parseInt(e.target.value, 10);
          if (!isNaN(newEpisodeIndex)) {
             playEpisode(CONFIG.stagioneIndex, newEpisodeIndex);
          }
      });
      
      function playEpisode(seasonIdx, episodeIdx) {
          console.log(`[VideoPlayer] Richiesta riproduzione Stagione ${seasonIdx + 1}, Episodio ${episodeIdx + 1}`);
          if (!currentSerieData || !currentSerieData.seasons[seasonIdx] || !currentSerieData.seasons[seasonIdx].episodes[episodeIdx]) {
              console.error("[VideoPlayer] Dati episodio non trovati per playEpisode."); return;
          }
          const episodeData = currentSerieData.seasons[seasonIdx].episodes[episodeIdx];
          if (!episodeData.file) { 
              console.error("[VideoPlayer] URL video (file) per l'episodio non trovato."); return;
          }

          CONFIG.stagioneIndex = seasonIdx; CONFIG.episodioIndex = episodeIdx;
          CONFIG.source = episodeData.file;
          CONFIG.title = episodeData.name || episodeData.title || `Stagione ${seasonIdx + 1} - Episodio ${episodeIdx + 1}`;
          document.title = CONFIG.title;

          skipIntroStart = (episodeData.skipIntroStart ? parseTime(episodeData.skipIntroStart) : 0) || (currentSerieData.skipIntroStart ? parseTime(currentSerieData.skipIntroStart) : 0);
          skipIntroEnd = (episodeData.skipIntroEnd ? parseTime(episodeData.skipIntroEnd) : 0) || (currentSerieData.skipIntroEnd ? parseTime(currentSerieData.skipIntroEnd) : 0);
          outroStart = (episodeData.outroStart ? parseTime(episodeData.outroStart) : 0) || (currentSerieData.outroStart ? parseTime(currentSerieData.outroStart) : 0);
          
          initialStartTime = 0; 
          
          const newUrl = new URL(window.location);
          newUrl.searchParams.set('serieId', CONFIG.serieId);
          newUrl.searchParams.set('stagioneIndex', seasonIdx.toString());
          newUrl.searchParams.set('episodioIndex', episodeIdx.toString());
          newUrl.searchParams.set('videoUrl', CONFIG.source);
          newUrl.searchParams.set('title', CONFIG.title);
          newUrl.searchParams.delete('startTime');
          if(CONFIG.contentType) newUrl.searchParams.set('contentType', CONFIG.contentType);
          if(CONFIG.returnTo && CONFIG.returnTo !== 'StreamRoot.html') newUrl.searchParams.set('returnTo', CONFIG.returnTo);
          window.history.pushState({ path: newUrl.href }, CONFIG.title, newUrl.href);

          loadSource(CONFIG.source);
      }

      // --- Navigation ---
      backToCatalogButton.addEventListener('click', () => { 
          console.log("[VideoPlayer] Torno al catalogo:", CONFIG.returnTo);
          window.location.href = CONFIG.returnTo; 
      });
      
      // --- Play/Pause & Video Event Handlers ---
      function togglePlayPause() { 
          if (video.readyState < video.HAVE_ENOUGH_DATA && video.networkState === video.NETWORK_LOADING && video.src) {
              console.log("[VideoPlayer] Video non ancora pronto, play/pausa ignorato."); return;
          }
          if (video.paused || video.ended) { 
              const playPromise = video.play();
              if (playPromise !== undefined) { // Controlla che play() restituisca una Promise
                playPromise.catch(e => console.warn("[VideoPlayer] Errore comando play:", e.message, e.name));
              } else {
                console.warn("[VideoPlayer] video.play() non ha restituito una Promise in togglePlayPause.");
              }
          } else { video.pause(); }
      }
      playPauseBtn.addEventListener('click', togglePlayPause); 
      video.addEventListener('click', togglePlayPause); 

      video.addEventListener('play', () => { 
        playPauseBtn.textContent = '‚è∏Ô∏è'; playPauseBtn.setAttribute('aria-label', 'Pausa'); playPauseBtn.title = 'Pausa';
        pauseOverlay.style.display = 'none'; 
        showControls(); 
        if (!hasAttemptedInitialFullscreen && isUserInteracted && !document.fullscreenElement) {
          console.log("[VideoPlayer] Tentativo autofullscreen su evento 'play'.");
          enterFullscreen() 
            .catch(err => console.warn("[VideoPlayer] Autofullscreen non riuscito:", err.message));
          hasAttemptedInitialFullscreen = true; 
        }
      });

      video.addEventListener('pause', () => { 
        playPauseBtn.textContent = '‚ñ∂Ô∏è'; playPauseBtn.setAttribute('aria-label', 'Play'); playPauseBtn.title = 'Play';
        if (!isDraggingSeekBar && video.readyState >= video.HAVE_FUTURE_DATA) { 
          pauseOverlay.style.display = 'block'; 
          setTimeout(() => { if(video.paused) pauseOverlay.style.display = 'none'; }, 600);
        }
        showControls(); 
      });

      video.addEventListener('ended', () => { 
          console.log("[VideoPlayer] Video terminato.");
          if (!isFilmSimple && currentSerieData) {
              let { stagioneIndex: currentSIdx, episodioIndex: currentEIdx } = CONFIG;
              let nextSIdx = currentSIdx, nextEIdx = currentEIdx + 1;

              if (currentSerieData.seasons[currentSIdx] && currentSerieData.seasons[currentSIdx].episodes[nextEIdx]) {
                  console.log("[VideoPlayer] Passaggio automatico al prossimo episodio nella stessa stagione.");
                  playEpisode(nextSIdx, nextEIdx);
              } else {
                  nextSIdx = currentSIdx + 1; nextEIdx = 0;
                  if (currentSerieData.seasons[nextSIdx] && currentSerieData.seasons[nextSIdx].episodes[nextEIdx]) {
                      console.log("[VideoPlayer] Passaggio automatico al primo episodio della prossima stagione.");
                      playEpisode(nextSIdx, nextEIdx);
                  } else {
                      console.log("[VideoPlayer] Fine serie o stagione.");
                      playPauseBtn.textContent = '‚ñ∂Ô∏è'; 
                  }
              }
          } else { playPauseBtn.textContent = '‚ñ∂Ô∏è'; }
      });

      // --- Fullscreen ---
      function enterFullscreen() {
        return new Promise((resolve, reject) => {
          if (playerContainer.requestFullscreen) {
            playerContainer.requestFullscreen().then(resolve).catch(reject);
          } else if (playerContainer.webkitRequestFullscreen) { /* Safari */
            playerContainer.webkitRequestFullscreen().then(resolve).catch(reject);
          } else if (playerContainer.msRequestFullscreen) { /* IE11 */
            playerContainer.msRequestFullscreen().then(resolve).catch(reject);
          } else {
            reject(new Error("Fullscreen API non supportata"));
          }
        });
      }

      function exitFullscreen() {
        return new Promise((resolve, reject) => {
          if (document.exitFullscreen) {
            document.exitFullscreen().then(resolve).catch(reject);
          } else if (document.webkitExitFullscreen) { /* Safari */
            document.webkitExitFullscreen().then(resolve).catch(reject);
          } else if (document.msExitFullscreen) { /* IE11 */
            document.msExitFullscreen().then(resolve).catch(reject);
          } else {
            reject(new Error("Fullscreen API non supportata per uscire"));
          }
        });
      }

      fullscreenBtn.addEventListener('click', () => {
        if (!document.fullscreenElement) {
          enterFullscreen().catch(e => console.warn("Errore attivazione fullscreen:", e.message));
        } else {
          exitFullscreen().catch(e => console.warn("Errore disattivazione fullscreen:", e.message));
        }
      });

      const fullscreenEvents = ['fullscreenchange', 'webkitfullscreenchange', 'msfullscreenchange'];
      fullscreenEvents.forEach(event => {
        document.addEventListener(event, () => {
          const isCurrentlyFullscreen = document.fullscreenElement === playerContainer || 
                                       document.webkitFullscreenElement === playerContainer || 
                                       document.msFullscreenElement === playerContainer;
          if (isCurrentlyFullscreen) {
            playerContainer.classList.add('fullscreen');
            fullscreenBtn.textContent = '‚Üò‚Üô'; 
            fullscreenBtn.title = "Esci da Schermo Intero";
            fullscreenBtn.setAttribute('aria-label', "Esci da Schermo Intero");
          } else {
            playerContainer.classList.remove('fullscreen');
            fullscreenBtn.textContent = '‚õ∂'; 
            fullscreenBtn.title = "Schermo Intero";
            fullscreenBtn.setAttribute('aria-label', "Attiva Schermo Intero");
          }
        });
      });
      video.addEventListener('dblclick', (e) => {
        e.preventDefault(); 
        const isCurrentlyFullscreen = document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
        if (!isCurrentlyFullscreen) {
          enterFullscreen().catch(err => console.warn("Errore fullscreen su dblclick:", err.message));
        } else {
          exitFullscreen().catch(err => console.warn("Errore exit fullscreen su dblclick:", err.message));
        }
      });
      
      // --- Volume & Speed ---
      volumeSlider.addEventListener('input', () => { 
          video.volume = parseFloat(volumeSlider.value);
          video.muted = video.volume === 0; // Se lo slider va a 0, muta.
          // L'evento 'volumechange' aggiorner√† l'icona.
      });
      video.addEventListener('volumechange', () => {
          volumeSlider.value = video.muted ? 0 : video.volume;
          if (video.muted || video.volume === 0) {
            volumeIcon.textContent = 'üîá';
            volumeIcon.setAttribute('aria-label', 'Audio Muto');
            volumeIcon.title = 'Attiva Audio';
          } else if (video.volume < 0.5) {
            volumeIcon.textContent = 'üîâ';
            volumeIcon.setAttribute('aria-label', 'Audio Basso');
            volumeIcon.title = 'Muto';
          } else {
            volumeIcon.textContent = 'üîä';
            volumeIcon.setAttribute('aria-label', 'Audio Alto');
            volumeIcon.title = 'Muto';
          }
      });
      volumeIcon.addEventListener('click', () => { 
          video.muted = !video.muted;
          if (!video.muted && video.volume === 0) { 
              video.volume = 0.5; // Se si smutare e il volume era 0, impostalo a un valore di default
          }
          // L'evento 'volumechange' aggiorner√† lo slider e l'icona
      });
      speedSelector.addEventListener('change', () => video.playbackRate = parseFloat(speedSelector.value));

      // --- Progress Bar & Time Update ---
      function updateTimeDisplay() {
        if (isNaN(video.duration)) {
            timeDisplay.textContent = formatTime(video.currentTime) + ' / --:--';
        } else {
            timeDisplay.textContent = formatTime(video.currentTime) + ' / ' + formatTime(video.duration);
        }
      }
      function updateProgressBar() {
          if (video.duration > 0 && isFinite(video.duration)) {
              const percentage = (video.currentTime / video.duration) * 100;
              progressFilled.style.width = `${percentage}%`;
              progressHandle.style.left = `${percentage}%`;
          } else {
              progressFilled.style.width = '0%';
              progressHandle.style.left = '0%';
          }
      }
      function updateBufferedBar() {
        if (video.buffered.length > 0 && video.duration > 0 && isFinite(video.duration)) {
          const bufferedEnd = video.buffered.end(video.buffered.length - 1);
          const bufferedPercentage = (bufferedEnd / video.duration) * 100;
          progressBuffered.style.width = `${bufferedPercentage}%`;
        } else {
          progressBuffered.style.width = '0%';
        }
      }

      video.addEventListener('loadedmetadata', () => {
          console.log("[VideoPlayer] Metadati caricati. Durata:", video.duration, "ReadyState:", video.readyState);
          updateTimeDisplay(); updateProgressBar(); updateBufferedBar();
          
          if (previewVideo.src !== video.src && (!video.src.includes('.m3u8') || previewVideo.canPlayType('application/vnd.apple.mpegurl'))) {
            previewVideo.src = video.src;
            previewVideo.load(); // Assicura che i metadati della preview video siano caricati
          } else if (video.src.includes('.m3u8') && !previewVideo.canPlayType('application/vnd.apple.mpegurl')) {
            console.log("[VideoPlayer] Preview video non impostata per HLS su browser senza supporto nativo.");
          }
          
          if (initialStartTime > 0 && video.currentTime < 1 && video.duration > initialStartTime && isFinite(video.duration)) { 
              console.log("[VideoPlayer] Imposto tempo iniziale a:", initialStartTime);
              video.currentTime = initialStartTime; 
              initialStartTime = 0; 
          }

          if (!video.src.includes('.m3u8')) { // Per MP4 e HLS nativo
            if (isUserInteracted) {
                console.log("[VideoPlayer] loadedmetadata, chiamo setupAndPlay() perch√© isUserInteracted=true");
                setupAndPlay();
            } else {
                console.log("[VideoPlayer] loadedmetadata, isUserInteracted=false, play non avviato.");
                playPauseBtn.textContent = '‚ñ∂Ô∏è'; playPauseBtn.setAttribute('aria-label', 'Play'); playPauseBtn.title = 'Play';
            }
          }
      }); 
      video.addEventListener('timeupdate', () => {
        updateTimeDisplay();
        updateProgressBar();
        // Skip Intro/Outro logic (Qui puoi inserire la logica per mostrare pulsanti o saltare automaticamente)
        // Esempio: if (skipIntroStart > 0 && skipIntroEnd > 0 && video.currentTime > skipIntroStart && video.currentTime < skipIntroEnd) { /* mostra pulsante "Salta Intro" */ }
      }); 
      video.addEventListener('progress', updateBufferedBar); 
      video.addEventListener('durationchange', () => {
        console.log("[VideoPlayer] Durata video cambiata:", video.duration);
        updateTimeDisplay();
        updateProgressBar();
        updateBufferedBar();
      });

      // --- Seek Bar Logic ---
      function seek(event) {
          if (isNaN(video.duration) || video.duration <= 0 || !isFinite(video.duration)) return;
          const progressBarRect = progressBar.getBoundingClientRect();
          const clickPositionInBar = event.clientX - progressBarRect.left;
          const time = (clickPositionInBar / progressBarRect.width) * video.duration;
          video.currentTime = Math.max(0, Math.min(time, video.duration));
          updateProgressBar(); 
          updateTimeDisplay(); // Aggiorna anche il tempo subito
      }
      progressBar.addEventListener('click', seek);

      progressHandle.addEventListener('mousedown', (e) => {
          if (isNaN(video.duration) || video.duration <= 0 || !isFinite(video.duration)) return;
          e.preventDefault(); 
          isDraggingSeekBar = true;
          progressHandle.classList.add('dragging');
          document.addEventListener('mousemove', handleDocumentMouseMove);
          document.addEventListener('mouseup', handleDocumentMouseUp, { once: true });
          showControls(); 
      });

      function handleDocumentMouseMove(e) {
          if (!isDraggingSeekBar || isNaN(video.duration) || video.duration <= 0 || !isFinite(video.duration)) return;
          const progressBarRect = progressBar.getBoundingClientRect();
          let newX = e.clientX - progressBarRect.left;
          newX = Math.max(0, Math.min(newX, progressBarRect.width)); // Limita all'interno della barra
          const time = (newX / progressBarRect.width) * video.duration;
          
          video.currentTime = time; // Imposta il tempo del video principale
          updateProgressBar(); // Aggiorna la barra visivamente
          updateTimeDisplay(); // Aggiorna anche il tempo
          
          const percentage = (newX / progressBarRect.width) * 100;
          if (previewVideo.src && previewVideo.readyState >= previewVideo.HAVE_METADATA && !isNaN(previewVideo.duration) && previewVideo.duration > 0) {
              previewThumb.style.display = 'block';
              const thumbWidthPercentage = (previewThumb.offsetWidth / progressBarRect.width) * 100;
              let thumbLeftPercentage = percentage - (thumbWidthPercentage / 2);
              thumbLeftPercentage = Math.max(0, Math.min(thumbLeftPercentage, 100 - thumbWidthPercentage));
              previewThumb.style.left = `${thumbLeftPercentage}%`;
              if(!previewVideo.paused) previewVideo.pause(); // Pausa la preview se stava andando
              previewVideo.currentTime = time; // Imposta il tempo della preview video
          } else {
              tooltip.style.display = 'block';
              tooltip.textContent = formatTime(time);
              tooltip.style.left = `${percentage}%`;
          }
      }

      function handleDocumentMouseUp() {
          if (isDraggingSeekBar) {
              isDraggingSeekBar = false;
              progressHandle.classList.remove('dragging');
              document.removeEventListener('mousemove', handleDocumentMouseMove);
              previewThumb.style.display = 'none';
              tooltip.style.display = 'none';
              if (!video.paused) showControls(); // Ripristina il timeout di hideControls
          }
      }

      // --- Preview Thumbnail & Tooltip ---
      progressBar.addEventListener('mousemove', e => {
          if (isDraggingSeekBar || isNaN(video.duration) || video.duration <= 0 || !isFinite(video.duration)) return;
          const progressBarRect = progressBar.getBoundingClientRect();
          const hoverPositionInBar = e.clientX - progressBarRect.left;
          const time = (hoverPositionInBar / progressBarRect.width) * video.duration;
          const percentage = (hoverPositionInBar / progressBarRect.width) * 100;

          if (previewVideo.src && previewVideo.readyState >= previewVideo.HAVE_METADATA && !isNaN(previewVideo.duration) && previewVideo.duration > 0) {
              previewThumb.style.display = 'block';
              const thumbWidthPercentage = (previewThumb.offsetWidth / progressBarRect.width) * 100;
              let thumbLeftPercentage = percentage - (thumbWidthPercentage / 2);
              thumbLeftPercentage = Math.max(0, Math.min(thumbLeftPercentage, 100 - thumbWidthPercentage));
              previewThumb.style.left = `${thumbLeftPercentage}%`;
              if(!previewVideo.paused) previewVideo.pause();
              previewVideo.currentTime = Math.max(0, Math.min(time, previewVideo.duration));
              tooltip.style.display = 'none'; 
          } else {
              tooltip.style.display = 'block';
              tooltip.textContent = formatTime(time);
              tooltip.style.left = `${percentage}%`; 
              previewThumb.style.display = 'none'; 
          }
      });
      progressBar.addEventListener('mouseout', () => {
          if (isDraggingSeekBar) return;
          previewThumb.style.display = 'none';
          tooltip.style.display = 'none';
      });

      // --- Controls Visibility ---
      function showControls() {
        clearTimeout(hideControlsTimeout);
        controls.classList.remove('hidden');
        if (!video.paused && !isDraggingSeekBar) { 
            hideControlsTimeout = setTimeout(() => {
                if (document.activeElement && controls.contains(document.activeElement)) {
                    showControls(); 
                    return;
                }
                controls.classList.add('hidden');
            }, 3000);
        }
      }
      playerContainer.addEventListener('mousemove', showControls); 
      playerContainer.addEventListener('mouseenter', showControls);
      playerContainer.addEventListener('focusin', showControls); 
      playerContainer.addEventListener('mouseleave', () => {
        if (!video.paused && !isDraggingSeekBar && !(document.activeElement && controls.contains(document.activeElement))) {
            clearTimeout(hideControlsTimeout); 
            hideControlsTimeout = setTimeout(() => controls.classList.add('hidden'), 500); 
        }
      });
      controls.addEventListener('mouseenter', () => clearTimeout(hideControlsTimeout)); 
      controls.addEventListener('mouseleave', () => { 
        if (!video.paused) showControls(); 
      });
      
      // --- Video Source Loading ---
      const setupAndPlay = () => {
          console.log("[VideoPlayer] Eseguo setupAndPlay(). ReadyState:", video.readyState, "isUserInteracted:", isUserInteracted);
          if (!isUserInteracted) {
              console.log("[VideoPlayer] setupAndPlay: Utente non ha interagito, play non avviato. Bottone su Play.");
              playPauseBtn.textContent = '‚ñ∂Ô∏è'; playPauseBtn.setAttribute('aria-label', 'Play'); playPauseBtn.title = 'Play';
              return;
          }

          video.volume = parseFloat(volumeSlider.value);
          // Non modificare video.muted qui basandosi solo sullo slider, per non sovrascrivere l'azione dell'icona mute.
          // L'evento volumechange si occuper√† di sincronizzare slider e icona.
          // Se lo slider √® a 0, video.muted sar√† true (gestito da listener di volumeSlider).
          video.playbackRate = parseFloat(speedSelector.value);

          const playPromise = video.play();
          if (playPromise !== undefined) {
              playPromise.then(() => {
                  console.log("[VideoPlayer] Play avviato con successo tramite setupAndPlay.");
              }).catch(error => {
                  if (error.name === 'NotAllowedError') { 
                      console.warn('[VideoPlayer] Autoplay bloccato da setupAndPlay. L\'utente dovr√† cliccare play.'); 
                      playPauseBtn.textContent = '‚ñ∂Ô∏è'; playPauseBtn.setAttribute('aria-label', 'Play'); playPauseBtn.title = 'Play';
                  } else { 
                      console.error('[VideoPlayer] Errore durante il tentativo di play da setupAndPlay:', error.message, error.name); 
                      playPauseBtn.textContent = '‚ñ∂Ô∏è'; playPauseBtn.setAttribute('aria-label', 'Play'); playPauseBtn.title = 'Play';
                  }
              });
          } else {
            console.warn("[VideoPlayer] video.play() non ha restituito una Promise in setupAndPlay. Stato video:", video.readyState, "Src:", video.src);
          }
      };

      function loadSource(src) { 
          console.log("[VideoPlayer] loadSource chiamato con src:", src);
          if (!src) { 
              console.error("[VideoPlayer] Nessuna sorgente video fornita."); 
              timeDisplay.textContent = 'Errore / No Source'; return; 
          } 
          
          video.poster = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; 
          hasAttemptedInitialFullscreen = false;
          
          if (hlsInstance) { hlsInstance.destroy(); hlsInstance = null; } 

          video.volume = parseFloat(volumeSlider.value);
          if (parseFloat(volumeSlider.value) === 0) video.muted = true; // Se slider √® 0, parte muto
          // Altrimenti, lo stato di video.muted √® preservato (potrebbe essere stato impostato dall'icona)
          video.playbackRate = parseFloat(speedSelector.value);
          console.log(`[VideoPlayer] Stato pre-caricamento: Volume=${video.volume}, Muted=${video.muted}, Rate=${video.playbackRate}`);
          
          // Resetta UI per nuova sorgente
          progressFilled.style.width = '0%';
          progressHandle.style.left = '0%';
          progressBuffered.style.width = '0%';
          timeDisplay.textContent = '00:00 / 00:00';
          playPauseBtn.textContent = '‚ñ∂Ô∏è'; playPauseBtn.setAttribute('aria-label', 'Play'); playPauseBtn.title = 'Play';


          if (src.includes('.m3u8')) { 
              if (Hls.isSupported()) { 
                  console.log("[VideoPlayer] Caricamento HLS stream...");
                  hlsInstance = new Hls({ /* debug: true, */ }); 
                  hlsInstance.loadSource(src); 
                  hlsInstance.attachMedia(video); 
                  hlsInstance.on(Hls.Events.MANIFEST_PARSED, (event, data) => { 
                      console.log("[VideoPlayer] HLS Manifest Parsed."); 
                      if (isUserInteracted) {
                        console.log("[VideoPlayer] MANIFEST_PARSED, chiamo setupAndPlay() perch√© isUserInteracted=true");
                        setupAndPlay();
                      } else {
                        console.log("[VideoPlayer] MANIFEST_PARSED, autoplay non tentato perch√© isUserInteracted=false. Bottone su Play.");
                        playPauseBtn.textContent = '‚ñ∂Ô∏è'; playPauseBtn.setAttribute('aria-label', 'Play'); playPauseBtn.title = 'Play';
                      }
                  }); 
                  hlsInstance.on(Hls.Events.ERROR, (event, data) => {
                    console.error('[VideoPlayer] HLS Error:', data.type, data.details, data.fatal);
                    if (data.fatal) {
                      let errorMsg = 'Errore HLS';
                      switch (data.type) {
                        case Hls.ErrorTypes.NETWORK_ERROR: errorMsg = 'Errore Rete HLS'; break;
                        case Hls.ErrorTypes.MEDIA_ERROR: errorMsg = 'Errore Media HLS'; break;
                        default: errorMsg = 'Errore HLS Irrecuperabile'; break;
                      }
                      timeDisplay.textContent = errorMsg;
                    }
                  });
                  if (previewVideo.canPlayType('application/vnd.apple.mpegurl')) { 
                    previewVideo.src = src; previewVideo.load();
                  }
              } else if (video.canPlayType('application/vnd.apple.mpegurl')) { 
                  console.log("[VideoPlayer] Caricamento HLS stream (nativo).");
                  video.src = src; 
                  if (previewVideo.canPlayType('application/vnd.apple.mpegurl')) { previewVideo.src = src; previewVideo.load(); }
              } else { 
                  console.error('[VideoPlayer] HLS non supportato.'); 
                  alert('HLS non supportato dal browser.'); 
                  timeDisplay.textContent = 'HLS non supportato';
              }
          } else { 
              console.log("[VideoPlayer] Caricamento video diretto (MP4 o altro).");
              video.src = src; 
              if (previewVideo.src !== src) { previewVideo.src = src; previewVideo.load(); }
          } 
          
          video.onerror = (e) => {
            console.error('[VideoPlayer] Errore elemento Video:', e, video.error);
            let errorMsg = 'Errore Video';
            if (video.error) {
                switch (video.error.code) {
                    case video.error.MEDIA_ERR_ABORTED: errorMsg = 'Caricamento interrotto.'; break;
                    case video.error.MEDIA_ERR_NETWORK: errorMsg = 'Errore di rete.'; break;
                    case video.error.MEDIA_ERR_DECODE: errorMsg = 'Errore decodifica.'; break;
                    case video.error.MEDIA_ERR_SRC_NOT_SUPPORTED: errorMsg = 'Formato non supportato.'; break;
                    default: errorMsg = 'Errore video sconosciuto.'; break;
                }
            }
            timeDisplay.textContent = errorMsg;
            playPauseBtn.textContent = '‚ñ∂Ô∏è'; 
          };
      }
      
      // --- INITIALIZATION ---
      console.log("[VideoPlayer] Inizializzazione player...");
      loadSerieDataFromStorage(); 
      
      video.volume = parseFloat(volumeSlider.value);
      video.muted = (parseFloat(volumeSlider.value) === 0); 
      video.dispatchEvent(new Event('volumechange')); 

      video.playbackRate = parseFloat(speedSelector.value);
      updateTimeDisplay(); 
      updateProgressBar(); 
      updateBufferedBar(); 
      
      // Inizialmente i controlli sono visibili, poi si nascondono se il mouse non √® sopra
      showControls(); 
      // Se non c'√® una sorgente, potrebbero rimanere sempre visibili
      // Questo timeout serve a nasconderli se l'utente non interagisce subito
      if (CONFIG.source) {
        clearTimeout(hideControlsTimeout); // Cancella il timeout impostato da showControls()
        hideControlsTimeout = setTimeout(() => {
            if (!playerContainer.matches(':hover') && !controls.matches(':hover')) {
                 controls.classList.add('hidden');
            }
        }, 3000); 
      }


      if (CONFIG.source) { 
        console.log("[VideoPlayer] Caricamento sorgente video iniziale:", CONFIG.source);
        loadSource(CONFIG.source); 
      } else { 
        console.warn("[VideoPlayer] Nessuna sorgente video iniziale specificata."); 
        if (currentSerieData && currentSerieData.seasons && currentSerieData.seasons.length > 0 &&
            !isNaN(CONFIG.stagioneIndex) && !isNaN(CONFIG.episodioIndex) &&
            currentSerieData.seasons[CONFIG.stagioneIndex] && currentSerieData.seasons[CONFIG.stagioneIndex].episodes[CONFIG.episodioIndex]) {
            console.log("[VideoPlayer] Tentativo di caricare l'episodio specificato da CONFIG.");
            playEpisode(CONFIG.stagioneIndex, CONFIG.episodioIndex);
        } else if (!isFilmSimple && currentSerieData && episodeSelectorGroup.style.display === 'flex') {
            timeDisplay.textContent = 'Seleziona Episodio';
        } else if (isFilmSimple) {
           alert("Nessun video da caricare. Specificare 'videoUrl'."); timeDisplay.textContent = 'Nessun Video';
        } else {
           alert("Dati serie non trovati o corrotti e nessuna sorgente specificata."); timeDisplay.textContent = 'Errore Dati';
        }
      }

    })(); 
  </script>
</body>
</html>
