<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catalogo Multimediale</title>
    <style>
        /* CSS (Manteniamo quello precedente, ma aggiungiamo/modifichiamo per stagioni/episodi) */
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; background-color: #141414; color: #e0e0e0; display: flex; flex-direction: column; min-height: 100vh; }
        header { background-color: #101010; padding: 1rem 2rem; box-shadow: 0 2px 8px rgba(0,0,0,0.5); position: sticky; top: 0; z-index: 1000; }
        nav { display: flex; justify-content: space-between; align-items: center; max-width: 1200px; margin: 0 auto; }
        nav .logo { font-size: 1.8em; font-weight: bold; color: #e50914; }
        nav ul { list-style: none; padding: 0; margin: 0; display: flex; gap: 1.5rem; }
        nav ul li a { text-decoration: none; color: #b0b0b0; font-size: 1.1em; font-weight: 500; transition: color 0.3s ease, text-shadow 0.3s ease; }
        nav ul li a:hover, nav ul li a.active { color: #ffffff; text-shadow: 0 0 5px rgba(229, 9, 20, 0.7); }
        .search-container { display: flex; gap: 0.5rem; }
        .search-container input[type="search"] { padding: 0.6rem 0.8rem; border-radius: 4px; border: 1px solid #333; background-color: #222; color: #fff; min-width: 220px; font-size: 0.9em; }
        .search-container input[type="search"]::placeholder { color: #777; }
        .search-container button { padding: 0.6rem 1.2rem; border-radius: 4px; border: none; background-color: #e50914; color: #fff; cursor: pointer; font-weight: 500; transition: background-color 0.3s ease; }
        .search-container button:hover { background-color: #f40612; }
        main { flex-grow: 1; padding: 2rem; max-width: 1200px; width: 90%; margin: 0 auto; }
        #section-header { display: flex; align-items: center; gap: 1rem; margin-bottom: 1.5rem; }
        #current-section-title { margin-bottom: 0; flex-grow: 1; font-size: 2.2em; color: #fff; text-align: left; border-bottom: 2px solid #333; padding-bottom: 0.5rem; }
        #back-button { padding: 0.5rem 1rem; background-color: #333; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em; transition: background-color 0.3s ease; }
        #back-button:hover { background-color: #555; }
        #back-button.hidden { display: none; }
        .grid-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 2rem; }
        #items-grid:not(.grid-container) { display: block; } /* Per layout lista episodi/stagioni */

        .card { background-color: #1f1f1f; border-radius: 8px; overflow: hidden; box-shadow: 0 5px 15px rgba(0,0,0,0.3); transition: transform 0.3s ease, box-shadow 0.3s ease; display: flex; flex-direction: column; }
        .card:hover { transform: translateY(-8px) scale(1.03); box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
        .card img { width: 100%; height: 380px; object-fit: cover; display: block; cursor: pointer; border-bottom: 3px solid #e50914; }
        .card-content { padding: 1rem 1.2rem; text-align: left; flex-grow: 1; display: flex; flex-direction: column; }
        .card-content h3 { margin-top: 0; margin-bottom: 0.5rem; font-size: 1.4em; color: #fff; line-height: 1.3; }
        .card-content p.description { font-size: 0.9em; color: #b0b0b0; line-height: 1.5; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; max-height: calc(1.5em * 3); margin-bottom: 0.75rem; flex-grow: 1; }
        .tags-container { margin-top: auto; padding-top: 0.5rem; display: flex; flex-wrap: wrap; gap: 0.4rem; }
        .tag { background-color: #333; color: #ccc; padding: 0.25rem 0.6rem; border-radius: 12px; font-size: 0.75em; font-weight: 500; }
        
        /* Stili per la vista dettaglio Serie/Anime e lista stagioni/episodi */
        .detail-view-container { width: 100%; padding: 1rem; background-color: #1f1f1f; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .detail-header { display: flex; gap: 1.5rem; margin-bottom: 2rem; padding-bottom: 1.5rem; border-bottom: 1px solid #333; }
        .detail-header img { width: 200px; height: auto; max-height: 300px; object-fit: cover; border-radius: 4px; }
        .detail-header-info { flex: 1; }
        .detail-header-info h3 { margin-top: 0; font-size: 2em; color: #fff; }
        .detail-header-info p { font-size: 1em; color: #b0b0b0; line-height: 1.6; }
        .detail-tags { margin-top: 1rem; }

        .seasons-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 1rem; margin-bottom: 2rem; }
        .season-card { background-color: #2a2a2a; border-radius: 6px; padding: 1rem; text-align: center; cursor: pointer; transition: background-color 0.3s ease; }
        .season-card:hover { background-color: #383838; }
        .season-card img { width: 100%; height: auto; max-height: 150px; object-fit: cover; border-radius: 4px; margin-bottom: 0.5rem; }
        .season-card h4 { margin: 0.5rem 0; font-size: 1.2em; }
        .season-card p { font-size: 0.8em; color: #888; margin: 0; }
        
        .episodes-list-section h4 { font-size: 1.6em; color: #e0e0e0; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid #444; }
        .episodes-list { list-style: none; padding: 0; margin: 0; }
        .episodes-list li { background-color: #2a2a2a; margin-bottom: 0.5rem; padding: 0.8rem 1.2rem; border-radius: 4px; cursor: pointer; transition: background-color 0.3s ease, transform 0.2s ease; display: flex; justify-content: space-between; align-items: center; }
        .episodes-list li:hover { background-color: #e50914; color: #fff; transform: translateX(5px); }
        .episodes-list li .episode-info { display: flex; align-items: center; gap: 10px; }
        .episodes-list li .episode-info img { width: 80px; height: 45px; object-fit: cover; border-radius: 3px;}
        .episodes-list li .episode-title-desc .main-title { display: block; }
        .episodes-list li .episode-title-desc .ep-desc { font-size: 0.8em; color: #999; display: block; margin-top: 3px; max-width: 400px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
        .episodes-list li:hover .ep-desc { color: #eee; }
        .episodes-list li .play-icon { font-size: 1.2em; margin-left: 1rem; }

        footer { text-align: center; padding: 1.5rem; background-color: #101010; color: #777; margin-top: auto; font-size: 0.9em; }
        .message { font-size: 1.2em; color: #aaa; text-align: center; padding: 2rem; grid-column: 1 / -1; }
    </style>
</head>
<body>
    <header>
        <nav>
            <div class="logo">MioStream</div>
            <ul>
                <li><a href="#home" id="nav-home" class="active">Home</a></li>
                <li><a href="#film" id="nav-film">Film</a></li>
                <li><a href="#serietv" id="nav-serietv">Serie TV</a></li>
                <li><a href="#anime" id="nav-anime">Anime</a></li>
            </ul>
            <div class="search-container">
                <input type="search" id="search-input" placeholder="Cerca titolo o tag...">
                <button id="search-button">Cerca</button>
            </div>
        </nav>
    </header>

    <main id="content-area">
        <div id="section-header">
            <button id="back-button" class="hidden">← Indietro</button>
            <h2 id="current-section-title">Caricamento...</h2>
        </div>
        <div id="items-grid" class="grid-container">
            <!-- Contenuto dinamico qui -->
        </div>
    </main>

    <footer>
        <p>© 2024 Catalogo Multimediale Moderno</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const itemsGrid = document.getElementById('items-grid');
            const searchInput = document.getElementById('search-input');
            const searchButton = document.getElementById('search-button');
            const navHome = document.getElementById('nav-home');
            const navFilm = document.getElementById('nav-film');
            const navSerieTv = document.getElementById('nav-serietv');
            const navAnime = document.getElementById('nav-anime');
            const sectionTitleElement = document.getElementById('current-section-title');
            const backButton = document.getElementById('back-button');

            let allFilm = [];
            let allSerieTv = [];
            let allAnime = [];
            let allContent = [];
            let currentView = 'grid'; // 'grid', 'serieDetail', 'seasonEpisodes'
            let breadcrumbs = []; // [{hash: '#home', title: 'Home'}] - per il pulsante indietro

            const GITHUB_FILM_URL = 'https://raw.githubusercontent.com/Server21/IPTV-Pro/master/Random/film.json';
            const GITHUB_SERIETV_URL = 'https://raw.githubusercontent.com/Server21/IPTV-Pro/master/Random/series_tv.json';
            const GITHUB_ANIME_URL = 'https://raw.githubusercontent.com/Server21/IPTV-Pro/master/Random/anime.json';

            async function fetchData() {
                try {
                    updateMainView("Caricamento...", '<p class="message">Recupero dati...</p>');
                    const responses = await Promise.all([
                        fetch(GITHUB_FILM_URL), fetch(GITHUB_SERIETV_URL), fetch(GITHUB_ANIME_URL)
                    ]);
                    responses.forEach(res => { if (!res.ok) throw new Error(`Errore HTTP: ${res.status}`); });
                    const [filmData, serieTvData, animeData] = await Promise.all(responses.map(res => res.json()));
                    
                    allFilm = filmData.map(mapFilmData);
                    allSerieTv = serieTvData.map(item => mapSerieOrAnimeData(item, 'serietv'));
                    allAnime = animeData.map(item => mapSerieOrAnimeData(item, 'anime'));
                    allContent = [...allFilm, ...allSerieTv, ...allAnime];
                    
                    handleRouteChange(true); // true per indicare caricamento iniziale
                } catch (error) { 
                    console.error('Errore fetchData:', error); 
                    updateMainView("Errore", `<p class="message">Impossibile caricare. ${error.message}</p>`);
                }
            }

            const mapFilmData = (item) => ({ 
                id: item.id || generateId(item.title), type: 'film',
                titolo: item.title || item.name || "N/D", 
                immagine: item.poster_path || item.image || item.thumbnail || "https://via.placeholder.com/300x450?text=No+Image",
                descrizione: item.overview || item.description || "N/D",
                url_video: item.url_video || item.video_url || item.file || item.link,
                tags: item.genres || item.tags || []
            });

            const mapSerieOrAnimeData = (item, type) => ({
                id: item.id || generateId(item.title), type: type,
                titolo: item.title || item.name || "N/D",
                immagine: item.poster_path || item.image || item.thumbnail || "https://via.placeholder.com/300x450?text=No+Image",
                descrizione: item.overview || item.description || "N/D",
                tags: item.genres || item.tags || [],
                stagioni: (item.seasons || item.stagioni || []).map((s, seasonIndex) => ({ 
                    id_stagione: s.id_stagione || generateId(s.season_name || s.name || `Stagione ${seasonIndex + 1}`),
                    stagione_numero: s.season_number || s.season_name || s.name || `Stagione ${seasonIndex + 1}`,
                    titolo_stagione: s.titolo_stagione || s.name,
                    immagine_stagione: s.poster_path || s.image_stagione || item.immagine, // fallback all'immagine della serie
                    season_index_internal: seasonIndex, 
                    episodes: (s.episodes || []).map((ep, episodeIndex) => ({
                        id_episodio: ep.id_episodio || generateId(ep.title || ep.name || `Episodio ${episodeIndex + 1}`),
                        episodio_numero: ep.episode_number || ep.episode || episodeIndex + 1,
                        titolo_episodio: ep.name || ep.title || `Episodio ${episodeIndex + 1}`,
                        link: ep.video_url || ep.file || ep.link,
                        descrizione_episodio: ep.overview || ep.description_episodio,
                        immagine_episodio: ep.still_path || ep.image_episodio,
                        skipIntroStart: ep.skipIntroStart, 
                        skipIntroEnd: ep.skipIntroEnd,     
                        outroStart: ep.outroStart,         
                        episode_index_internal: episodeIndex,
                        type: type // Aggiungi type all'episodio per playVideo
                    }))
                }))
            });
            const generateId = (str) => str ? str.replace(/\s+/g, '-').toLowerCase() : Math.random().toString(36).substring(2);

            function updateMainView(title, contentHtml, isGridView = false) {
                sectionTitleElement.textContent = title;
                itemsGrid.innerHTML = contentHtml;
                if (isGridView) {
                    itemsGrid.classList.add('grid-container');
                    itemsGrid.classList.remove('detail-view-container');
                } else {
                    itemsGrid.classList.remove('grid-container');
                    itemsGrid.classList.add('detail-view-container'); 
                }
            }
            
            function updateBackButton() {
                if (breadcrumbs.length > 1) {
                    backButton.classList.remove('hidden');
                    // Il pulsante indietro ora torna all'hash precedente nello stack breadcrumbs
                } else {
                    backButton.classList.add('hidden');
                }
            }
            backButton.addEventListener('click', () => {
                if (breadcrumbs.length > 1) {
                    breadcrumbs.pop(); // Rimuovi la vista corrente
                    const previousState = breadcrumbs[breadcrumbs.length - 1];
                    window.location.hash = previousState.hash; 
                    // handleRouteChange sarà chiamato da hashchange
                }
            });


            function playVideo(itemData, serieOrAnimeId, stagioneIndex, episodioIndex) {
                let playerUrl = `player.html?videoUrl=${encodeURIComponent(itemData.link || itemData.url_video)}`;
                if (itemData.type !== 'film' && (itemData.skipIntroStart || itemData.skipIntroEnd || itemData.outroStart)) {
                    if (itemData.skipIntroStart) playerUrl += `&skipIntroStart=${encodeURIComponent(itemData.skipIntroStart)}`;
                    if (itemData.skipIntroEnd) playerUrl += `&skipIntroEnd=${encodeURIComponent(itemData.skipIntroEnd)}`;
                    if (itemData.outroStart) playerUrl += `&outroStart=${encodeURIComponent(itemData.outroStart)}`;
                }
                if (serieOrAnimeId !== undefined) {
                    playerUrl += `&serieId=${encodeURIComponent(serieOrAnimeId)}`;
                    playerUrl += `&stagioneIndex=${stagioneIndex}`;
                    playerUrl += `&episodioIndex=${episodioIndex}`;
                    playerUrl += `&contentType=${itemData.type}`;
                    // Passa l'hash corrente di Casa.html per permettere al player di tornare qui
                    playerUrl += `&returnTo=${encodeURIComponent(window.location.hash || '#home')}`;
                }
                window.location.href = playerUrl;
            }

            function createItemCard(item) {
                const card = document.createElement('div');
                card.className = 'card';
                let tagsHtml = '';
                if (item.tags && Array.isArray(item.tags) && item.tags.length > 0) {
                    const tagNames = item.tags.map(tag => typeof tag === 'object' && tag.name ? tag.name : tag);
                    tagsHtml = `<div class="tags-container">${tagNames.filter(t => typeof t === 'string').map(tag => `<span class="tag">${tag}</span>`).join('')}</div>`;
                }
                card.innerHTML = `<img src="${item.immagine}" alt="${item.titolo}"><div class="card-content"><h3>${item.titolo}</h3><p class="description">${item.descrizione}</p>${tagsHtml}</div>`;
                card.addEventListener('click', () => {
                    if (item.type === 'film') {
                        if (item.url_video) playVideo(item);
                        else alert("URL video non disponibile.");
                    } else { // Serie TV o Anime
                        window.location.hash = `#detail&type=${item.type}&id=${item.id}`;
                    }
                });
                return card;
            }

            function displaySerieDetail(item) { // Può essere serie o anime
                currentView = 'serieDetail';
                let tagsHtml = '';
                if (item.tags && item.tags.length > 0) {
                    const tagNames = item.tags.map(tag => typeof tag === 'object' && tag.name ? tag.name : tag);
                    tagsHtml = `<div class="tags-container detail-tags">${tagNames.filter(t => typeof t === 'string').map(tag => `<span class="tag">${tag}</span>`).join('')}</div>`;
                }

                let seasonsHtml = '<p class="message">Nessuna stagione disponibile.</p>';
                if (item.stagioni && item.stagioni.length > 0) {
                    seasonsHtml = `<div class="seasons-grid">` + item.stagioni.map((stagione, index) => `
                        <div class="season-card" data-serie-id="${item.id}" data-season-index="${index}" data-type="${item.type}">
                            <img src="${stagione.immagine_stagione || item.immagine}" alt="Stagione ${stagione.stagione_numero}">
                            <h4>Stagione ${stagione.stagione_numero}</h4>
                            ${stagione.titolo_stagione ? `<p>${stagione.titolo_stagione}</p>` : ''}
                        </div>
                    `).join('') + `</div>`;
                }

                const contentHtml = `
                    <div class="detail-header">
                        <img src="${item.immagine}" alt="${item.titolo}">
                        <div class="detail-header-info">
                            <h3>${item.titolo}</h3>
                            <p>${item.descrizione}</p>
                            ${tagsHtml}
                        </div>
                    </div>
                    ${seasonsHtml}
                `;
                updateMainView(item.titolo, contentHtml);
                
                document.querySelectorAll('.season-card').forEach(card => {
                    card.addEventListener('click', () => {
                        const serieId = card.dataset.serieId;
                        const seasonIndex = parseInt(card.dataset.seasonIndex, 10);
                        const type = card.dataset.type;
                        window.location.hash = `#season&type=${type}&id=${serieId}&seasonIndex=${seasonIndex}`;
                    });
                });
            }

            function displaySeasonEpisodes(item, seasonIndex) { // item è la serie/anime
                currentView = 'seasonEpisodes';
                const stagione = item.stagioni[seasonIndex];
                if (!stagione) { updateMainView("Errore", "<p>Stagione non trovata.</p>"); return; }

                let episodesHtml = '<p class="message">Nessun episodio in questa stagione.</p>';
                if (stagione.episodes && stagione.episodes.length > 0) {
                    episodesHtml = `<ul class="episodes-list">` + stagione.episodes.map(ep => `
                        <li data-serie-id="${item.id}" data-season-index="${seasonIndex}" data-episode-index="${ep.episode_index_internal}" data-type="${item.type}">
                            <div class="episode-info">
                                ${ep.immagine_episodio ? `<img src="${ep.immagine_episodio}" alt="Ep. ${ep.episodio_numero}">` : ''}
                                <div class="episode-title-desc">
                                   <span class="main-title">Ep. ${ep.episodio_numero}: ${ep.titolo_episodio}</span>
                                   ${ep.descrizione_episodio ? `<span class="ep-desc">${ep.descrizione_episodio}</span>` : ''}
                                </div>
                            </div>
                            <span class="play-icon">▶</span>
                        </li>
                    `).join('') + `</ul>`;
                }
                const contentHtml = `<div class="episodes-list-section"><h4>Stagione ${stagione.stagione_numero} - Episodi</h4>${episodesHtml}</div>`;
                updateMainView(`${item.titolo} - Stagione ${stagione.stagione_numero}`, contentHtml);

                document.querySelectorAll('.episodes-list li').forEach(li => {
                    li.addEventListener('click', () => {
                        const serieId = li.dataset.serieId;
                        const sIndex = parseInt(li.dataset.seasonIndex, 10);
                        const epIndex = parseInt(li.dataset.episodeIndex, 10);
                        const type = li.dataset.type;
                        const collection = type === 'serietv' ? allSerieTv : allAnime;
                        const serieItem = collection.find(s => s.id === serieId);
                        const episodeData = serieItem.stagioni[sIndex].episodes[epIndex];
                        if (episodeData && episodeData.link) {
                            playVideo(episodeData, serieId, sIndex, epIndex);
                        } else { alert("URL video non disponibile."); }
                    });
                });
            }
            
            function playNextEpisodeLogic(serieId, currentStagioneIndex, currentEpisodioIndex, contentType) {
                const collection = contentType === 'serietv' ? allSerieTv : (contentType === 'anime' ? allAnime : null);
                if (!collection) { console.error("Tipo di contenuto non valido per playNext:", contentType); return; }
                const serie = collection.find(s => s.id === serieId);
                if (!serie) { console.error("Serie/Anime non trovato per playNext:", serieId); return; }

                currentStagioneIndex = parseInt(currentStagioneIndex, 10);
                currentEpisodioIndex = parseInt(currentEpisodioIndex, 10);

                let nextEp = null;
                let nextStagioneIndex = currentStagioneIndex;
                let nextEpisodioIndex = currentEpisodioIndex + 1;

                if (serie.stagioni[currentStagioneIndex] && serie.stagioni[currentStagioneIndex].episodes[nextEpisodioIndex]) {
                    nextEp = serie.stagioni[currentStagioneIndex].episodes[nextEpisodioIndex];
                } else { 
                    nextStagioneIndex = currentStagioneIndex + 1;
                    nextEpisodioIndex = 0;
                    if (serie.stagioni[nextStagioneIndex] && serie.stagioni[nextStagioneIndex].episodes[nextEpisodioIndex]) {
                        // È il primo episodio della prossima stagione
                        if (confirm(`Hai terminato la Stagione ${serie.stagioni[currentStagioneIndex].stagione_numero}. Vuoi passare alla Stagione ${serie.stagioni[nextStagioneIndex].stagione_numero}?`)) {
                            nextEp = serie.stagioni[nextStagioneIndex].episodes[nextEpisodioIndex];
                        } else {
                            window.location.hash = `#detail&type=${contentType}&id=${serieId}`; // Torna ai dettagli della serie
                            return;
                        }
                    } else {
                        // Fine di tutte le stagioni
                        alert(`Hai completato tutti gli episodi di ${serie.titolo}!`);
                        window.location.hash = `#home`; // O `#detail&type=${contentType}&id=${serieId}`
                        return;
                    }
                }

                if (nextEp && nextEp.link) {
                    playVideo(nextEp, serieId, nextStagioneIndex, nextEpisodioIndex);
                } else {
                    console.log("Link per il prossimo episodio non trovato o utente ha annullato.");
                     window.location.hash = `#detail&type=${contentType}&id=${serieId}`;
                }
            }


            function displayGrid(items, title) { currentView = 'grid'; updateMainView(title, items.map(item => createItemCard(item).outerHTML).join(''), true); }
            function displayHome() { setActiveNav(navHome); displayGrid(getRandomItems(allContent, 12), 'Home - Consigliati'); }
            function getRandomItems(array, count) { if (!array || array.length === 0) return []; const shuffled = [...array].sort(() => 0.5 - Math.random()); return shuffled.slice(0, Math.min(count, shuffled.length)); }
            function displayFilm() { setActiveNav(navFilm); displayGrid(allFilm, 'Tutti i Film'); }
            function displaySerieTv() { setActiveNav(navSerieTv); displayGrid(allSerieTv, 'Tutte le Serie TV'); }
            function displayAnime() { setActiveNav(navAnime); displayGrid(allAnime, 'Tutti gli Anime'); }
            function handleSearch() { const searchTerm = searchInput.value.toLowerCase().trim(); if (!searchTerm) { window.location.hash = breadcrumbs.length > 1 ? breadcrumbs[breadcrumbs.length - 2].hash : '#home'; return; } const filtered = allContent.filter(item => (item.titolo.toLowerCase().includes(searchTerm) || (item.tags && item.tags.some(tag => (typeof tag === 'object' ? tag.name : tag).toLowerCase().includes(searchTerm))))); displayGrid(filtered, `Risultati per: "${searchInput.value}"`); setActiveNav(null); breadcrumbs = [{hash: `#search&q=${encodeURIComponent(searchTerm)}`, title:`Ricerca: ${searchInput.value}`}]; updateBackButton(); }
            function setActiveNav(activeLink) { [navHome, navFilm, navSerieTv, navAnime].forEach(link => { if (link) link.classList.remove('active'); }); if (activeLink) { activeLink.classList.add('active'); } }
            
            function handleRouteChange(initialLoad = false) {
                const hash = window.location.hash || '#home';
                let currentRouteState = { hash: hash, title: '' };

                // Gestione #playNext prima di tutto
                if (hash.startsWith('#playNext')) {
                    const params = new URLSearchParams(hash.substring(hash.indexOf('?') + 1));
                    const serieId = params.get('serieId');
                    const stagioneIndex = params.get('stagioneIndex');
                    const episodioIndex = params.get('episodioIndex');
                    const contentType = params.get('contentType');
                    
                    // Rimuovi l'hash per evitare che rimanga nell'URL e causi loop
                    // Usa lo stato precedente se disponibile, altrimenti home
                    const prevHashForHistory = breadcrumbs.length > 1 ? breadcrumbs[breadcrumbs.length-1].hash : '#home';
                    history.replaceState(null, null, window.location.pathname + window.location.search + prevHashForHistory); 

                    if (serieId && stagioneIndex !== null && episodioIndex !== null && contentType) {
                        if (allContent.length > 0) {
                            playNextEpisodeLogic(serieId, stagioneIndex, episodioIndex, contentType);
                        } else {
                            fetchData().then(() => playNextEpisodeLogic(serieId, stagioneIndex, episodioIndex, contentType));
                        }
                    }
                    return; 
                }


                // Aggiorna breadcrumbs solo se l'hash è diverso dall'ultimo o se è caricamento iniziale
                if (initialLoad || (breadcrumbs.length === 0 || breadcrumbs[breadcrumbs.length - 1].hash !== hash)) {
                     // Logica per non duplicare se si usa il tasto back del browser
                    const existingCrumbIndex = breadcrumbs.findIndex(b => b.hash === hash);
                    if (existingCrumbIndex !== -1 && existingCrumbIndex < breadcrumbs.length -1) {
                        breadcrumbs = breadcrumbs.slice(0, existingCrumbIndex + 1);
                    } else if (existingCrumbIndex === -1) {
                         // Aggiungi solo se non è un "indietro" a uno stato già presente
                         // Il titolo verrà impostato dalla funzione di display specifica
                         breadcrumbs.push(currentRouteState);
                    }
                }
                 if (breadcrumbs.length > 10) breadcrumbs.shift(); // Limita la dimensione


                const parts = hash.substring(1).split('&');
                const route = parts[0];
                const params = new URLSearchParams(parts.slice(1).join('&'));

                switch (route) {
                    case 'film': currentRouteState.title = 'Tutti i Film'; displayFilm(); break;
                    case 'serietv': currentRouteState.title = 'Tutte le Serie TV'; displaySerieTv(); break;
                    case 'anime': currentRouteState.title = 'Tutti gli Anime'; displayAnime(); break;
                    case 'detail': {
                        const type = params.get('type');
                        const id = params.get('id');
                        const collection = type === 'serietv' ? allSerieTv : allAnime;
                        const item = collection.find(s => s.id === id);
                        if (item) { currentRouteState.title = item.titolo; displaySerieDetail(item); }
                        else { window.location.hash = '#home'; } // Fallback
                        break;
                    }
                    case 'season': {
                        const type = params.get('type');
                        const id = params.get('id');
                        const seasonIndex = parseInt(params.get('seasonIndex'), 10);
                        const collection = type === 'serietv' ? allSerieTv : allAnime;
                        const item = collection.find(s => s.id === id);
                        if (item && item.stagioni[seasonIndex]) {
                            currentRouteState.title = `${item.titolo} - S${item.stagioni[seasonIndex].stagione_numero}`;
                            displaySeasonEpisodes(item, seasonIndex);
                        } else { window.location.hash = '#home'; } // Fallback
                        break;
                    }
                    case 'search': {
                        const query = params.get('q');
                        if (query) { searchInput.value = query; handleSearch(); }
                        else { displayHome(); }
                        break;
                    }
                    case 'home': default: currentRouteState.title = 'Home'; displayHome(); break;
                }
                if(breadcrumbs.length > 0 && breadcrumbs[breadcrumbs.length -1].hash === hash) {
                    breadcrumbs[breadcrumbs.length -1].title = currentRouteState.title; // Aggiorna titolo dell'ultimo breadcrumb
                }
                updateBackButton();
            }

            [navHome, navFilm, navSerieTv, navAnime].forEach(navLink => { 
                navLink.addEventListener('click', (e) => {
                    // Non serve preventDefault perché usiamo hash per routing
                    // Pulisci breadcrumbs quando si naviga da navbar a una sezione principale
                    const targetHash = e.currentTarget.getAttribute('href');
                    breadcrumbs = [{hash: targetHash, title: ''}]; // Il titolo sarà settato da handleRouteChange
                }); 
            });
            window.addEventListener('hashchange', () => handleRouteChange(false)); // false per non duplicare breadcrumb
            searchButton.addEventListener('click', () => {
                const query = searchInput.value.trim();
                if (query) {
                     window.location.hash = `#search&q=${encodeURIComponent(query)}`;
                }
            });
            searchInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') searchButton.click(); });

            fetchData();
        });
    </script>
</body>
</html>
