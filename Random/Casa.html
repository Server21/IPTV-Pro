<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catalogo Multimediale</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; background-color: #141414; color: #e0e0e0; display: flex; flex-direction: column; min-height: 100vh; }
        header { background-color: #101010; padding: 1rem 2rem; box-shadow: 0 2px 8px rgba(0,0,0,0.5); position: sticky; top: 0; z-index: 1000; }
        nav { display: flex; justify-content: space-between; align-items: center; max-width: 1200px; margin: 0 auto; flex-wrap: wrap; /* Per navbar su più righe su mobile */ }
        nav .logo { font-size: 1.8em; font-weight: bold; color: #e50914; margin-right: auto; /* Spinge altri elementi a destra */}
        nav ul { list-style: none; padding: 0; margin: 0; display: flex; flex-wrap: wrap; gap: 0.5rem 1rem; /* Gap per mobile */ justify-content: center; /* Centra i link se vanno a capo */ }
        nav ul li a { text-decoration: none; color: #b0b0b0; font-size: 1em; font-weight: 500; transition: color 0.3s ease, text-shadow 0.3s ease; padding: 0.3rem 0.5rem; }
        @media (min-width: 768px) { nav { flex-wrap: nowrap; } nav ul { gap: 1.5rem; } nav ul li a { font-size: 1.1em; padding: 0; } }
        nav ul li a:hover, nav ul li a.active { color: #ffffff; text-shadow: 0 0 5px rgba(229, 9, 20, 0.7); }
        
        .search-container { display: flex; gap: 0.5rem; margin-top: 0.5rem; width:100%;}
        @media (min-width: 600px) { .search-container { width: auto; margin-top: 0; margin-left: 1rem;} }
        .search-container input[type="search"] { padding: 0.6rem 0.8rem; border-radius: 4px; border: 1px solid #333; background-color: #222; color: #fff; flex-grow: 1; min-width: 150px; font-size: 0.9em; }
        .search-container button { padding: 0.6rem 1rem; border-radius: 4px; border: none; background-color: #e50914; color: #fff; cursor: pointer; font-weight: 500; transition: background-color 0.3s ease; }
        .search-container button:hover { background-color: #f40612; }

        main { flex-grow: 1; padding: 1rem; max-width: 1300px; width: 100%; margin: 0 auto; box-sizing: border-box; }
        #section-header { display: flex; align-items: center; gap: 1rem; margin-bottom: 1.5rem; padding: 0 0.5rem; }
        @media (min-width: 768px) { main { padding: 2rem; } #section-header { padding: 0; } }
        #current-section-title { margin-bottom: 0; flex-grow: 1; font-size: clamp(1.5em, 4vw, 2.2em); color: #fff; text-align: left; border-bottom: 2px solid #333; padding-bottom: 0.5rem; }
        #back-button { padding: 0.4rem 0.8rem; font-size: clamp(0.8em, 2.5vw, 0.9em); background-color: #333; color: #fff; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s ease;}
        #back-button:hover { background-color: #555; }
        #back-button.hidden { display: none; }

        .grid-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); /* Più piccole per mobile */ gap: 0.8rem; }
        @media (min-width: 480px) { .grid-container { grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); } }
        @media (min-width: 768px) { .grid-container { grid-template-columns: repeat(auto-fill, minmax(190px, 1fr)); gap: 1.2rem; } }
        @media (min-width: 1024px) { .grid-container { grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 1.5rem; } }
        #items-grid:not(.grid-container) { display: block; }

        .card { background-color: #1f1f1f; border-radius: 8px; overflow: hidden; box-shadow: 0 3px 10px rgba(0,0,0,0.3); transition: transform 0.2s ease, box-shadow 0.2s ease; display: flex; flex-direction: column; }
        .card:hover { transform: translateY(-6px) scale(1.02); box-shadow: 0 8px 20px rgba(0,0,0,0.4); }
        .card img { width: 100%; aspect-ratio: 2 / 3; object-fit: cover; display: block; cursor: pointer; border-bottom: 2px solid #e50914; }
        .card-content { padding: 0.6rem 0.8rem; text-align: left; flex-grow: 1; display: flex; flex-direction: column; min-height: 70px; }
        .card-content h3 { margin-top: 0; margin-bottom: 0.3rem; font-size: clamp(0.85em, 2.8vw, 1em); color: #fff; line-height: 1.2; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
        .card-content p.description { font-size: clamp(0.7em, 2.2vw, 0.8em); color: #b0b0b0; line-height: 1.3; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; margin-bottom: 0.4rem; flex-grow: 1; }
        .tags-container { margin-top: auto; padding-top: 0.3rem; display: flex; flex-wrap: wrap; gap: 0.25rem; }
        .tag { background-color: #333; color: #ccc; padding: 0.15rem 0.4rem; border-radius: 8px; font-size: clamp(0.55em, 1.8vw, 0.65em); font-weight: 500; }
        
        .detail-view-container { width: 100%; padding: 1rem; background-color: #181818; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .detail-header { display: flex; flex-direction: column; align-items: center; text-align: center; gap: 1rem; margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 1px solid #333; }
        .detail-header img { width: 150px; max-width: 50%; height: auto; object-fit: cover; border-radius: 4px; box-shadow: 0 4px 8px rgba(0,0,0,0.3);}
        .detail-header-info { flex: 1; width:100%;}
        .detail-header-info h3 { font-size: clamp(1.6em, 5vw, 2em); margin-bottom: 0.5rem; }
        .detail-header-info p { font-size: clamp(0.9em, 2.5vw, 1em); max-height: 150px; overflow-y: auto; line-height: 1.5; color: #ccc;}
        .detail-tags { margin-top: 0.8rem; }
        @media (min-width: 768px) { .detail-header { flex-direction: row; text-align: left; align-items: flex-start;} .detail-header img {max-width: 200px;} .detail-header-info p {max-height: 200px;} }

        .seasons-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.8rem; margin-bottom: 1.5rem; }
        .season-card { background-color: #2a2a2a; border-radius: 6px; padding: 0.8rem; text-align: center; cursor: pointer; transition: background-color 0.3s ease, transform 0.2s ease; display: flex; flex-direction: column; justify-content: space-between; }
        .season-card:hover { background-color: #383838; transform: scale(1.03); }
        .season-card img { width: 100%; aspect-ratio: 16 / 9; object-fit: cover; border-radius: 4px; margin-bottom: 0.5rem; }
        .season-card h4 { margin: 0.5rem 0; font-size: clamp(0.85em, 2.8vw, 1em); white-space: nowrap; overflow:hidden; text-overflow: ellipsis;}
        .season-card p { font-size: 0.75em; color: #888; margin: 0; }
        @media (min-width: 768px) { .seasons-grid { grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 1rem; } }

        .episodes-list-section h4 { font-size: clamp(1.3em, 4vw, 1.6em); color: #e0e0e0; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid #444; }
        .episodes-list { list-style: none; padding: 0; margin: 0; }
        .episodes-list li { background-color: #2a2a2a; margin-bottom: 0.5rem; padding: 0.6rem 1rem; border-radius: 4px; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; display: flex; justify-content: space-between; align-items: center; }
        .episodes-list li:hover { background-color: #e50914; color: #fff; transform: translateX(3px); }
        .episodes-list li .episode-info { display: flex; align-items: center; gap: 10px; overflow: hidden; flex-grow: 1;}
        .episodes-list li .episode-info img { width: 80px; aspect-ratio: 16 / 9; object-fit: cover; border-radius: 3px; flex-shrink: 0;}
        .episodes-list li .episode-title-desc { overflow: hidden; margin-right: 10px;}
        .episodes-list li .episode-title-desc .main-title { font-size: clamp(0.8em, 2.5vw, 0.95em); display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .episodes-list li .episode-title-desc .ep-desc { font-size: clamp(0.65em, 2vw, 0.75em); color: #999; display: block; margin-top: 3px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
        .episodes-list li:hover .ep-desc { color: #eee; }
        .episodes-list li .play-icon { font-size: 1.1em; margin-left: auto; flex-shrink: 0;}

        footer { text-align: center; padding: 1.5rem; background-color: #101010; color: #777; margin-top: auto; font-size: 0.9em; }
        .message { font-size: 1.2em; color: #aaa; text-align: center; padding: 2rem; grid-column: 1 / -1; }
    </style>
</head>
<body>
    <header>
        <nav>
            <div class="logo">MioStream</div>
            <ul>
                <li><a href="#home" id="nav-home" class="active">Home</a></li>
                <li><a href="#film" id="nav-film">Film</a></li>
                <li><a href="#serietv" id="nav-serietv">Serie TV</a></li>
                <li><a href="#anime" id="nav-anime">Anime</a></li>
            </ul>
            <div class="search-container">
                <input type="search" id="search-input" placeholder="Cerca titolo o tag...">
                <button id="search-button">Cerca</button>
            </div>
        </nav>
    </header>

    <main id="content-area">
        <div id="section-header">
            <button id="back-button" class="hidden">← Indietro</button>
            <h2 id="current-section-title">Caricamento...</h2>
        </div>
        <div id="items-grid" class="grid-container">
            <!-- Contenuto dinamico qui -->
        </div>
    </main>

    <footer>
        <p>© 2024 Catalogo Multimediale Moderno</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const itemsGrid = document.getElementById('items-grid');
            const searchInput = document.getElementById('search-input');
            const searchButton = document.getElementById('search-button');
            const navHome = document.getElementById('nav-home');
            const navFilm = document.getElementById('nav-film');
            const navSerieTv = document.getElementById('nav-serietv');
            const navAnime = document.getElementById('nav-anime'); 
            const sectionTitleElement = document.getElementById('current-section-title');
            const backButton = document.getElementById('back-button');

            let allFilm = [], allSerieTv = [], allAnime = [], allContent = [];
            let currentView = 'grid'; 
            let breadcrumbs = []; 

            const GITHUB_FILM_URL = 'https://raw.githubusercontent.com/Server21/IPTV-Pro/master/Random/film.json';
            const GITHUB_SERIETV_URL = 'https://raw.githubusercontent.com/Server21/IPTV-Pro/master/Random/series_tv.json';
            const GITHUB_ANIME_URL = 'https://raw.githubusercontent.com/Server21/IPTV-Pro/master/Random/anime.json';

            async function fetchData() {
                try {
                    updateMainView("Caricamento...", '<p class="message">Recupero dati...</p>');
                    const responses = await Promise.all([
                        fetch(GITHUB_FILM_URL), fetch(GITHUB_SERIETV_URL), fetch(GITHUB_ANIME_URL)
                    ].map(p => p.catch(e => { console.error("Fetch error:", e.message); return { ok: false, url: e.url || 'unknown', status: 'NetworkError' }; })) // Gestisce errori di rete
                    );
                    
                    const jsonData = [];
                    for (const res of responses) {
                        if (!res.ok) {
                            // Non bloccare tutto se un file fallisce, ma logga l'errore
                            console.error(`Errore HTTP caricando ${res.url}: ${res.status}`);
                            jsonData.push([]); // Aggiungi array vuoto per non rompere Promise.all successivo
                            continue;
                        }
                        try {
                            jsonData.push(await res.json());
                        } catch (e) {
                            console.error(`JSON non valido da ${res.url}: ${e.message}`);
                            jsonData.push([]); // Array vuoto in caso di JSON non valido
                        }
                    }
                    const [filmJson, serieTvJson, animeJson] = jsonData;
                    
                    allFilm = Array.isArray(filmJson) ? filmJson.map((item, index) => mapFilmData(item, index)) : [];
                    allSerieTv = Array.isArray(serieTvJson) ? serieTvJson.map((item, index) => mapSerieOrAnimeData(item, 'serietv', index)) : [];
                    allAnime = Array.isArray(animeJson) ? animeJson.map((item, index) => mapSerieOrAnimeData(item, 'anime', index)) : [];
                    allContent = [...allFilm, ...allSerieTv, ...allAnime];
                    
                    handleRouteChange(true); 
                } catch (error) { 
                    console.error('Errore critico in fetchData:', error); 
                    updateMainView("Errore", `<p class="message">Impossibile caricare. ${error.message}</p>`);
                }
            }

            const generateSafeId = (text, prefix = '') => {
                const randomPart = Math.random().toString(36).substring(2, 7);
                if (typeof text !== 'string' || !text.trim()) { return prefix + randomPart; }
                const safeText = text.trim().toLowerCase()
                                 .replace(/\s+/g, '-')      
                                 .replace(/[^\w-]+/g, '');   
                return prefix + (safeText || randomPart).substring(0, 40) + '-' + randomPart; // Aggiunge casualità per maggiore unicità
            }

            const mapFilmData = (item, index) => ({ 
                id: item.id_provided || generateSafeId(item.title, 'f-' + index + '-'), // Usa id_provided se c'è, altrimenti genera
                type: 'film',
                titolo: item.title || item.name || "N/D", 
                immagine: item.poster_path || item.image || item.thumbnail || "https://via.placeholder.com/300x450?text=No+Image",
                descrizione: item.overview || item.description || "N/D",
                url_video: item.url_video || item.video_url || item.file || item.link,
                tags: Array.isArray(item.genres) ? item.genres : (Array.isArray(item.tags) ? item.tags : [])
            });

            const mapSerieOrAnimeData = (item, type, itemIndex) => {
                const serieId = item.id_provided || generateSafeId(item.title, type.substring(0,1) + '-' + itemIndex + '-');
                return {
                    id: serieId, type: type,
                    titolo: item.title || item.name || "N/D", 
                    immagine: item.poster_path || item.image || item.thumbnail || "https://via.placeholder.com/300x450?text=No+Image",
                    descrizione: item.overview || item.description || "N/D",
                    tags: Array.isArray(item.genres) ? item.genres : (Array.isArray(item.tags) ? item.tags : []),
                    stagioni: (item.seasons || item.stagioni || []).map((s, seasonIndex) => {
                        const seasonTitle = s.title || s.name || s.titolo_stagione || `Stagione ${s.season_number || seasonIndex + 1}`;
                        const stagioneId = s.id_stagione_provided || generateSafeId(seasonTitle, `${serieId}_s${seasonIndex}-`);
                        return {
                            id_stagione: stagioneId,
                            stagione_numero: s.season_number || s.season_name || s.name || `Stagione ${seasonIndex + 1}`, 
                            titolo_stagione: seasonTitle,
                            immagine_stagione: s.poster_path || s.image_stagione || item.poster_path || item.image || item.thumbnail,
                            season_index_internal: seasonIndex, 
                            episodes: (s.episodes || []).map((ep, episodeIndex) => {
                                const episodeTitle = ep.name || ep.title || `Episodio ${ep.episode_number || episodeIndex + 1}`;
                                const episodioId = ep.id_episodio_provided || generateSafeId(episodeTitle, `${stagioneId}_e${episodeIndex}-`);
                                return {
                                    id_episodio: episodioId,
                                    episodio_numero: ep.episode_number || ep.episode || episodeIndex + 1, 
                                    titolo_episodio: episodeTitle, 
                                    link: ep.video_url || ep.file || ep.link, 
                                    descrizione_episodio: ep.overview || ep.description_episodio,
                                    immagine_episodio: ep.still_path || ep.image_episodio,
                                    skipIntroStart: ep.skipIntroStart, 
                                    skipIntroEnd: ep.skipIntroEnd,     
                                    outroStart: ep.outroStart,         
                                    episode_index_internal: episodeIndex,
                                    type: type 
                                };
                            })
                        };
                    })
                };
            };

            function updateMainView(title, contentHtml, isGridView = false) { sectionTitleElement.textContent = title; itemsGrid.innerHTML = contentHtml; itemsGrid.className = isGridView ? 'grid-container' : 'detail-view-container'; }
            function updateBackButton() { backButton.classList.toggle('hidden', breadcrumbs.length <= 1); }
            backButton.addEventListener('click', () => { if (breadcrumbs.length > 1) { breadcrumbs.pop(); const previousState = breadcrumbs[breadcrumbs.length - 1]; window.location.hash = previousState.hash; } });
            function playVideo(itemData, serieOrAnimeId, stagioneIndex, episodioIndex) { const videoLink = itemData.link || itemData.url_video; if (!videoLink) { alert("URL del video non trovato!"); return; } let playerUrl = `player.html?videoUrl=${encodeURIComponent(videoLink)}`; if (itemData.type !== 'film') { if (itemData.skipIntroStart) playerUrl += `&skipIntroStart=${encodeURIComponent(itemData.skipIntroStart)}`; if (itemData.skipIntroEnd) playerUrl += `&skipIntroEnd=${encodeURIComponent(itemData.skipIntroEnd)}`; if (itemData.outroStart) playerUrl += `&outroStart=${encodeURIComponent(itemData.outroStart)}`; } if (serieOrAnimeId !== undefined) { playerUrl += `&serieId=${encodeURIComponent(serieOrAnimeId)}`; playerUrl += `&stagioneIndex=${stagioneIndex}`; playerUrl += `&episodioIndex=${episodioIndex}`; playerUrl += `&contentType=${itemData.type}`; playerUrl += `&returnTo=${encodeURIComponent(window.location.hash || '#home')}`; } window.location.href = playerUrl; }

            function createItemCard(item) {
                const card = document.createElement('div'); card.className = 'card';
                let tagsHtml = '';
                if (item.tags && Array.isArray(item.tags) && item.tags.length > 0) {
                    const tagNames = item.tags.map(tag => (typeof tag === 'object' && tag.name) ? tag.name : (typeof tag === 'string' ? tag : null)).filter(Boolean);
                    if (tagNames.length > 0) tagsHtml = `<div class="tags-container">${tagNames.slice(0,3).map(tag => `<span class="tag">${tag}</span>`).join('')}</div>`; // Mostra max 3 tag
                }
                card.innerHTML = `<img src="${item.immagine}" alt="${item.titolo}" loading="lazy"><div class="card-content"><h3>${item.titolo}</h3><p class="description">${item.descrizione || ''}</p>${tagsHtml}</div>`;
                card.addEventListener('click', () => {
                    if (item.type === 'film') { if (item.url_video) playVideo(item); else alert("URL video non disponibile."); } 
                    else { window.location.hash = `#detail&type=${item.type}&id=${encodeURIComponent(item.id)}`; }
                });
                return card;
            }

            function displaySerieDetail(item) { 
                currentView = 'serieDetail';
                let tagsHtml = ''; /* ... */ if (item.tags && item.tags.length > 0) { const tN = item.tags.map(t=>(typeof t === 'object'&&t.name)?t.name:(typeof t ==='string'?t:null)).filter(Boolean); if(tN.length>0)tagsHtml=`<div class="tags-container detail-tags">${tN.map(t=>`<span class="tag">${t}</span>`).join('')}</div>`;}
                let seasonsHtml = '<p class="message">Nessuna stagione.</p>';
                if (item.stagioni && item.stagioni.length > 0) {
                    seasonsHtml = `<div class="seasons-grid">` + item.stagioni.map((stagione) => `
                        <div class="season-card" data-serie-id="${encodeURIComponent(item.id)}" data-season-index="${stagione.season_index_internal}" data-type="${item.type}">
                            <img src="${stagione.immagine_stagione || item.immagine}" alt="Stagione ${stagione.stagione_numero}" loading="lazy">
                            <h4>Stagione ${stagione.stagione_numero} ${stagione.titolo_stagione ? ` - ${stagione.titolo_stagione}` : ''}</h4>
                            <p>${stagione.episodes ? stagione.episodes.length : 0} episodi</p>
                        </div>
                    `).join('') + `</div>`;
                }
                const contentHtml = `<div class="detail-header"><img src="${item.immagine}" alt="${item.titolo}"><div class="detail-header-info"><h3>${item.titolo}</h3><p>${item.descrizione || ''}</p>${tagsHtml}</div></div>${seasonsHtml}`;
                updateMainView(item.titolo, contentHtml);
                document.querySelectorAll('.season-card').forEach(c => c.addEventListener('click', () => window.location.hash = `#season&type=${c.dataset.type}&id=${c.dataset.serieId}&seasonIndex=${c.dataset.seasonIndex}`));
            }

            function displaySeasonEpisodes(item, seasonIndex) { 
                currentView = 'seasonEpisodes';
                const stagione = item.stagioni[seasonIndex];
                if (!stagione) { updateMainView("Errore", "<p>Stagione non trovata.</p>"); return; }
                let episodesHtml = '<p class="message">Nessun episodio.</p>';
                if (stagione.episodes && stagione.episodes.length > 0) {
                    episodesHtml = `<ul class="episodes-list">` + stagione.episodes.map(ep => `
                        <li data-serie-id="${encodeURIComponent(item.id)}" data-season-index="${seasonIndex}" data-episode-index="${ep.episode_index_internal}" data-type="${item.type}">
                            <div class="episode-info">
                                ${ep.immagine_episodio ? `<img src="${ep.immagine_episodio}" alt="" loading="lazy">` : `<div style="width:90px; height:50px; background:#333; display:flex; align-items:center; justify-content:center; border-radius:3px;"><span style="font-size:0.8em; color:#777;">No Img</span></div>`}
                                <div class="episode-title-desc">
                                   <span class="main-title">Ep. ${ep.episodio_numero}: ${ep.titolo_episodio}</span>
                                   ${ep.descrizione_episodio ? `<span class="ep-desc">${ep.descrizione_episodio}</span>` : ''}
                                </div>
                            </div>
                            <span class="play-icon">▶</span>
                        </li>
                    `).join('') + `</ul>`;
                }
                const sTitle = stagione.titolo_stagione ? `Stagione ${stagione.stagione_numero} - ${stagione.titolo_stagione}` : `Stagione ${stagione.stagione_numero}`;
                updateMainView(`${item.titolo} - ${sTitle}`, `<div class="episodes-list-section"><h4>${sTitle} - Episodi</h4>${episodesHtml}</div>`);
                document.querySelectorAll('.episodes-list li').forEach(li => {
                    li.addEventListener('click', () => {
                        const sId=decodeURIComponent(li.dataset.serieId), sIdx=parseInt(li.dataset.seasonIndex), epIdx=parseInt(li.dataset.episodeIndex), type=li.dataset.type;
                        const coll = type === 'serietv' ? allSerieTv : allAnime;
                        const sItem = coll.find(s => s.id === sId);
                        const epData = sItem?.stagioni[sIdx]?.episodes[epIdx];
                        if (epData && epData.link) playVideo(epData, sId, sIdx, epIdx); else alert("URL video non disponibile.");
                    });
                });
            }
            
            function playNextEpisodeLogic(encodedSerieId, currentStagioneIndex, currentEpisodioIndex, contentType) {
                const serieId = decodeURIComponent(encodedSerieId); 
                const collection = contentType === 'serietv' ? allSerieTv : (contentType === 'anime' ? allAnime : null);
                if (!collection) return; const serie = collection.find(s => s.id === serieId); if (!serie) return;
                currentStagioneIndex = parseInt(currentStagioneIndex); currentEpisodioIndex = parseInt(currentEpisodioIndex);
                let nextEp, nextStagioneIndex = currentStagioneIndex, nextEpisodioIndex = currentEpisodioIndex + 1;
                if (serie.stagioni[currentStagioneIndex]?.episodes[nextEpisodioIndex]) {
                    nextEp = serie.stagioni[currentStagioneIndex].episodes[nextEpisodioIndex];
                } else { 
                    nextStagioneIndex = currentStagioneIndex + 1; nextEpisodioIndex = 0;
                    if (serie.stagioni[nextStagioneIndex]?.episodes[nextEpisodioIndex]) {
                        if (confirm(`Hai terminato Stagione ${serie.stagioni[currentStagioneIndex].stagione_numero}. Prossima Stagione (${serie.stagioni[nextStagioneIndex].stagione_numero})?`)) {
                            nextEp = serie.stagioni[nextStagioneIndex].episodes[nextEpisodioIndex];
                        } else { window.location.hash = `#detail&type=${contentType}&id=${encodeURIComponent(serieId)}`; return; }
                    } else { alert(`Hai completato ${serie.titolo}!`); window.location.hash = `#home`; return; }
                }
                if (nextEp && nextEp.link) playVideo(nextEp, serieId, nextStagioneIndex, nextEpisodioIndex);
                else { window.location.hash = `#detail&type=${contentType}&id=${encodeURIComponent(serieId)}`; }
            }

            function displayGrid(items, title) { currentView = 'grid'; updateMainView(title, items.map(item => createItemCard(item).outerHTML).join(''), true); }
            function displayHome() { setActiveNav(navHome); displayGrid(getRandomItems(allContent, 12), 'Home - Consigliati'); }
            function getRandomItems(array, count) { if (!array || array.length === 0) return []; const shuffled = [...array].sort(() => 0.5 - Math.random()); return shuffled.slice(0, Math.min(count, shuffled.length)); }
            function displayFilm() { setActiveNav(navFilm); displayGrid(allFilm, 'Tutti i Film'); }
            function displaySerieTv() { setActiveNav(navSerieTv); displayGrid(allSerieTv, 'Tutte le Serie TV'); }
            function displayAnime() { setActiveNav(navAnime); displayGrid(allAnime, 'Tutti gli Anime'); }
            
            function handleSearchRoute() {
                const searchTerm = searchInput.value.toLowerCase().trim(); 
                const currentHashForSearch = `#search&q=${encodeURIComponent(searchTerm)}`; 
                if (!searchTerm) { 
                    if(breadcrumbs.length > 1 && breadcrumbs[breadcrumbs.length-1].hash.startsWith("#search")) breadcrumbs.pop(); 
                    window.location.hash = breadcrumbs.length > 0 ? breadcrumbs[breadcrumbs.length - 1].hash : '#home'; 
                    return;
                }
                const filtered = allContent.filter(item => (item.titolo.toLowerCase().includes(searchTerm) || 
                    (item.tags && item.tags.some(tag => ((typeof tag === 'object' && tag.name) ? tag.name : (typeof tag === 'string' ? tag : '')).toLowerCase().includes(searchTerm))))); 
                const searchTitle = `Ricerca: "${searchInput.value}"`; 
                displayGrid(filtered, searchTitle); 
                setActiveNav(null);
                // Aggiorna o aggiungi breadcrumb per la ricerca
                const lastCrumb = breadcrumbs[breadcrumbs.length - 1];
                if (lastCrumb && lastCrumb.hash === currentHashForSearch) {
                    lastCrumb.title = searchTitle;
                } else {
                    breadcrumbs.push({hash: currentHashForSearch, title: searchTitle});
                }
                updateBackButton();
            }

            function setActiveNav(activeLink) { [navHome, navFilm, navSerieTv, navAnime].forEach(link => { if (link) link.classList.remove('active'); }); if (activeLink) { activeLink.classList.add('active'); } }
            
            function handleRouteChange(initialLoad = false) {
                const rawHash = window.location.hash || '#home';
                let pageTitle = "Catalogo"; 

                if (rawHash.startsWith('#playNext')) {
                    const params = new URLSearchParams(rawHash.substring(rawHash.indexOf('?') + 1));
                    const serieId = params.get('serieId'), stagIdx = params.get('stagioneIndex'), epIdx = params.get('episodioIndex'), cType = params.get('contentType');
                    const prevHashForHistory = breadcrumbs.length > 0 ? breadcrumbs[breadcrumbs.length - 1].hash : '#home';
                    history.replaceState(null, null, window.location.pathname + window.location.search + prevHashForHistory); 
                    if (serieId && stagIdx !== null && epIdx !== null && cType) {
                        if (allContent.length > 0) playNextEpisodeLogic(serieId, stagIdx, epIdx, cType);
                        else fetchData().then(() => playNextEpisodeLogic(serieId, stagIdx, epIdx, cType));
                    }
                    return; 
                }

                if (initialLoad) { breadcrumbs = [{hash: rawHash, title: pageTitle}]; } 
                else {
                    const existingCrumbIndex = breadcrumbs.findIndex(b => b.hash === rawHash);
                    if (existingCrumbIndex !== -1) { breadcrumbs = breadcrumbs.slice(0, existingCrumbIndex + 1); pageTitle = breadcrumbs[existingCrumbIndex].title; } 
                    else { breadcrumbs.push({hash: rawHash, title: pageTitle}); }
                }
                if (breadcrumbs.length > 10) breadcrumbs.shift();

                const parts = rawHash.substring(1).split('&'); const route = parts[0]; const params = new URLSearchParams(parts.slice(1).join('&'));
                switch (route) {
                    case 'film': pageTitle = 'Tutti i Film'; displayFilm(); break;
                    case 'serietv': pageTitle = 'Tutte le Serie TV'; displaySerieTv(); break;
                    case 'anime': pageTitle = 'Tutti gli Anime'; displayAnime(); break;
                    case 'detail': {
                        const type = params.get('type'), id = decodeURIComponent(params.get('id'));
                        const collection = type === 'serietv' ? allSerieTv : allAnime;
                        const item = collection.find(s => s.id === id);
                        if (item) { pageTitle = item.titolo; displaySerieDetail(item); } else { window.location.hash = '#home'; }
                        break;
                    }
                    case 'season': {
                        const type = params.get('type'), id = decodeURIComponent(params.get('id')), seasonIndex = parseInt(params.get('seasonIndex'));
                        const collection = type === 'serietv' ? allSerieTv : allAnime;
                        const item = collection.find(s => s.id === id);
                        if (item && item.stagioni[seasonIndex]) { const season = item.stagioni[seasonIndex]; pageTitle = `${item.titolo} - S${season.stagione_numero}`; displaySeasonEpisodes(item, seasonIndex); } 
                        else { window.location.hash = '#home'; }
                        break;
                    }
                     case 'search': {
                        const query = params.get('q'); pageTitle = `Ricerca: "${query || ''}"`;
                        if (query) { searchInput.value = query; handleSearchRoute(); } else { window.location.hash = '#home'; } 
                        break;
                    }
                    case 'home': default: pageTitle = 'Home'; displayHome(); break;
                }
                if(breadcrumbs.length > 0 && breadcrumbs[breadcrumbs.length - 1].hash === rawHash) { breadcrumbs[breadcrumbs.length - 1].title = pageTitle; }
                updateBackButton();
            }

            [navHome, navFilm, navSerieTv, navAnime].forEach(navLink => { 
                navLink.addEventListener('click', (e) => {
                    const targetHash = e.currentTarget.getAttribute('href');
                    // Se l'hash non cambia (già sulla pagina), forza il reset dei breadcrumbs e il re-render
                    // Altrimenti, resetta i breadcrumbs e lascia che hashchange gestisca il render
                    breadcrumbs = [{hash: targetHash, title: ''}]; 
                    if (window.location.hash === targetHash) {
                        handleRouteChange(true); // true per forzare come se fosse un caricamento iniziale della sezione
                    }
                }); 
            });
            window.addEventListener('hashchange', () => handleRouteChange(false));
            searchButton.addEventListener('click', () => { const query = searchInput.value.trim(); if (query) window.location.hash = `#search&q=${encodeURIComponent(query)}`; });
            searchInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') searchButton.click(); });

            fetchData();
        });
    </script>
</body>
</html>
