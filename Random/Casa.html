<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catalogo Multimediale</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; background-color: #141414; color: #e0e0e0; display: flex; flex-direction: column; min-height: 100vh; }
        header { background-color: #101010; padding: 1rem 2rem; box-shadow: 0 2px 8px rgba(0,0,0,0.5); position: sticky; top: 0; z-index: 1000; }
        nav { display: flex; justify-content: space-between; align-items: center; max-width: 1200px; margin: 0 auto; }
        nav .logo { font-size: 1.8em; font-weight: bold; color: #e50914; }
        nav ul { list-style: none; padding: 0; margin: 0; display: flex; flex-wrap: wrap; /* Per mobile */ gap: 1rem; /* Gap ridotto per mobile */ }
        nav ul li a { text-decoration: none; color: #b0b0b0; font-size: 1em; /* Leggermente ridotto */ font-weight: 500; transition: color 0.3s ease, text-shadow 0.3s ease; }
        @media (min-width: 768px) { nav ul { gap: 1.5rem; } nav ul li a { font-size: 1.1em; } }
        nav ul li a:hover, nav ul li a.active { color: #ffffff; text-shadow: 0 0 5px rgba(229, 9, 20, 0.7); }
        
        .search-container { display: flex; gap: 0.5rem; margin-top: 0.5rem; /* Spazio su mobile */ }
        @media (min-width: 768px) { .search-container { margin-top: 0; } }
        .search-container input[type="search"] { padding: 0.6rem 0.8rem; border-radius: 4px; border: 1px solid #333; background-color: #222; color: #fff; flex-grow: 1; /* Per riempire lo spazio */ min-width: 150px; font-size: 0.9em; }
        .search-container button { padding: 0.6rem 1rem; border-radius: 4px; border: none; background-color: #e50914; color: #fff; cursor: pointer; font-weight: 500; transition: background-color 0.3s ease; }
        .search-container button:hover { background-color: #f40612; }

        main { flex-grow: 1; padding: 1rem; max-width: 1300px; width: 100%; margin: 0 auto; box-sizing: border-box; }
        #section-header { display: flex; align-items: center; gap: 1rem; margin-bottom: 1.5rem; padding: 0 0.5rem; }
        @media (min-width: 768px) { main { padding: 2rem; } #section-header { padding: 0; } }
        #current-section-title { margin-bottom: 0; flex-grow: 1; font-size: clamp(1.5em, 4vw, 2.2em); color: #fff; text-align: left; border-bottom: 2px solid #333; padding-bottom: 0.5rem; }
        #back-button { padding: 0.4rem 0.8rem; font-size: clamp(0.8em, 2.5vw, 0.9em); background-color: #333; color: #fff; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s ease;}
        #back-button:hover { background-color: #555; }
        #back-button.hidden { display: none; }

        .grid-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 1rem; }
        @media (min-width: 480px) { .grid-container { grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); } }
        @media (min-width: 768px) { .grid-container { grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1.5rem; } }
        @media (min-width: 1024px) { .grid-container { grid-template-columns: repeat(auto-fill, minmax(230px, 1fr)); } }
        #items-grid:not(.grid-container) { display: block; }

        .card { background-color: #1f1f1f; border-radius: 8px; overflow: hidden; box-shadow: 0 5px 15px rgba(0,0,0,0.3); transition: transform 0.3s ease, box-shadow 0.3s ease; display: flex; flex-direction: column; }
        .card:hover { transform: translateY(-8px) scale(1.03); box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
        .card img { width: 100%; aspect-ratio: 2 / 3; object-fit: cover; display: block; cursor: pointer; border-bottom: 2px solid #e50914; }
        .card-content { padding: 0.6rem 0.8rem; text-align: left; flex-grow: 1; display: flex; flex-direction: column; min-height: 80px; }
        .card-content h3 { margin-top: 0; margin-bottom: 0.3rem; font-size: clamp(0.9em, 3vw, 1.1em); color: #fff; line-height: 1.2; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
        .card-content p.description { font-size: clamp(0.75em, 2.5vw, 0.85em); color: #b0b0b0; line-height: 1.3; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; margin-bottom: 0.4rem; flex-grow: 1; }
        .tags-container { margin-top: auto; padding-top: 0.3rem; display: flex; flex-wrap: wrap; gap: 0.25rem; }
        .tag { background-color: #333; color: #ccc; padding: 0.15rem 0.4rem; border-radius: 8px; font-size: clamp(0.6em, 2vw, 0.7em); font-weight: 500; }
        
        .detail-view-container { width: 100%; padding: 1rem; background-color: #1f1f1f; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .detail-header { display: flex; flex-direction: column; align-items: center; text-align: center; gap: 1rem; margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 1px solid #333; }
        .detail-header img { width: 150px; max-width: 50%; height: auto; object-fit: cover; border-radius: 4px; }
        .detail-header-info { flex: 1; width:100%;}
        .detail-header-info h3 { font-size: clamp(1.6em, 5vw, 2em); }
        .detail-header-info p { font-size: clamp(0.9em, 2.5vw, 1em); max-height: 150px; overflow-y: auto; }
        .detail-tags { margin-top: 1rem; }
        @media (min-width: 768px) { .detail-header { flex-direction: row; text-align: left; align-items: flex-start;} .detail-header img {max-width: 200px;} }

        .seasons-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 0.8rem; margin-bottom: 1.5rem; }
        .season-card { background-color: #2a2a2a; border-radius: 6px; padding: 0.8rem; text-align: center; cursor: pointer; transition: background-color 0.3s ease; display: flex; flex-direction: column; justify-content: space-between; }
        .season-card:hover { background-color: #383838; }
        .season-card img { width: 100%; aspect-ratio: 16 / 9; object-fit: cover; border-radius: 4px; margin-bottom: 0.5rem; }
        .season-card h4 { margin: 0.5rem 0; font-size: clamp(0.9em, 3vw, 1.1em); white-space: nowrap; overflow:hidden; text-overflow: ellipsis;}
        .season-card p { font-size: 0.8em; color: #888; margin: 0; }
        @media (min-width: 768px) { .seasons-grid { grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 1rem; } .season-card img { /* max-height: 150px; non serve con aspect-ratio */ } }

        .episodes-list-section h4 { font-size: clamp(1.3em, 4vw, 1.6em); }
        .episodes-list { list-style: none; padding: 0; margin: 0; }
        .episodes-list li { background-color: #2a2a2a; margin-bottom: 0.5rem; padding: 0.6rem 1rem; border-radius: 4px; cursor: pointer; transition: background-color 0.3s ease, transform 0.2s ease; display: flex; justify-content: space-between; align-items: center; }
        .episodes-list li:hover { background-color: #e50914; color: #fff; transform: translateX(5px); }
        .episodes-list li .episode-info { display: flex; align-items: center; gap: 10px; overflow: hidden;}
        .episodes-list li .episode-info img { width: 90px; aspect-ratio: 16 / 9; object-fit: cover; border-radius: 3px; flex-shrink: 0;}
        .episodes-list li .episode-title-desc { overflow: hidden; }
        .episodes-list li .episode-title-desc .main-title { font-size: clamp(0.85em, 2.8vw, 1em); display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .episodes-list li .episode-title-desc .ep-desc { font-size: clamp(0.7em, 2.2vw, 0.8em); color: #999; display: block; margin-top: 3px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
        .episodes-list li:hover .ep-desc { color: #eee; }
        .episodes-list li .play-icon { font-size: 1.2em; margin-left: 1rem; flex-shrink: 0;}

        footer { text-align: center; padding: 1.5rem; background-color: #101010; color: #777; margin-top: auto; font-size: 0.9em; }
        .message { font-size: 1.2em; color: #aaa; text-align: center; padding: 2rem; grid-column: 1 / -1; }
    </style>
</head>
<body>
    <header>
        <nav>
            <div class="logo">MioStream</div>
            <ul>
                <li><a href="#home" id="nav-home" class="active">Home</a></li>
                <li><a href="#film" id="nav-film">Film</a></li>
                <li><a href="#serietv" id="nav-serietv">Serie TV</a></li>
                <li><a href="#anime" id="nav-anime">Anime</a></li>
            </ul>
            <div class="search-container">
                <input type="search" id="search-input" placeholder="Cerca titolo o tag...">
                <button id="search-button">Cerca</button>
            </div>
        </nav>
    </header>

    <main id="content-area">
        <div id="section-header">
            <button id="back-button" class="hidden">← Indietro</button>
            <h2 id="current-section-title">Caricamento...</h2>
        </div>
        <div id="items-grid" class="grid-container">
            <!-- Contenuto dinamico qui -->
        </div>
    </main>

    <footer>
        <p>© 2024 Catalogo Multimediale Moderno</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const itemsGrid = document.getElementById('items-grid');
            const searchInput = document.getElementById('search-input');
            const searchButton = document.getElementById('search-button');
            const navHome = document.getElementById('nav-home');
            const navFilm = document.getElementById('nav-film');
            const navSerieTv = document.getElementById('nav-serietv');
            const navAnime = document.getElementById('nav-anime'); 
            const sectionTitleElement = document.getElementById('current-section-title');
            const backButton = document.getElementById('back-button');

            let allFilm = [], allSerieTv = [], allAnime = [], allContent = [];
            let currentView = 'grid'; 
            let breadcrumbs = []; 

            const GITHUB_FILM_URL = 'https://raw.githubusercontent.com/Server21/IPTV-Pro/master/Random/film.json';
            const GITHUB_SERIETV_URL = 'https://raw.githubusercontent.com/Server21/IPTV-Pro/master/Random/series_tv.json';
            const GITHUB_ANIME_URL = 'https://raw.githubusercontent.com/Server21/IPTV-Pro/master/Random/anime.json';

            async function fetchData() {
                try {
                    updateMainView("Caricamento...", '<p class="message">Recupero dati...</p>');
                    const responses = await Promise.all([
                        fetch(GITHUB_FILM_URL), fetch(GITHUB_SERIETV_URL), fetch(GITHUB_ANIME_URL)
                    ]);
                    responses.forEach(res => { if (!res.ok) throw new Error(`Errore HTTP: ${res.status} (${res.url})`); });
                    
                    const [filmJson, serieTvJson, animeJson] = await Promise.all(responses.map(async res => {
                        try { return await res.json(); } 
                        catch (e) { throw new Error(`JSON non valido da ${res.url}: ${e.message}`); }
                    }));
                    
                    allFilm = filmJson.map(mapFilmData);
                    allSerieTv = serieTvJson.map(item => mapSerieOrAnimeData(item, 'serietv'));
                    allAnime = animeJson.map(item => mapSerieOrAnimeData(item, 'anime'));
                    allContent = [...allFilm, ...allSerieTv, ...allAnime];
                    
                    handleRouteChange(true); 
                } catch (error) { 
                    console.error('Errore fetchData:', error); 
                    updateMainView("Errore", `<p class="message">Impossibile caricare. ${error.message}</p>`);
                }
            }

            const generateId = (str, prefix = '') => str ? prefix + str.toString().trim().replace(/\s+/g, '-').toLowerCase().replace(/[^a-z0-9-]/g, '') : prefix + Math.random().toString(36).substring(2);

            const mapFilmData = (item) => ({ 
                id: item.id || generateId(item.title, 'f-'), type: 'film',
                titolo: item.title || item.name || "N/D", 
                immagine: item.poster_path || item.image || item.thumbnail || "https://via.placeholder.com/300x450?text=No+Image",
                descrizione: item.overview || item.description || "N/D",
                url_video: item.url_video || item.video_url || item.file || item.link,
                tags: Array.isArray(item.genres) ? item.genres : (Array.isArray(item.tags) ? item.tags : [])
                // NO SKIP/OUTRO per film
            });

            const mapSerieOrAnimeData = (item, type) => ({
                id: item.id || generateId(item.title, type.substring(0,1) + '-'), type: type,
                titolo: item.title || item.name || "N/D", // Titolo Anime/Serie
                immagine: item.poster_path || item.image || item.thumbnail || "https://via.placeholder.com/300x450?text=No+Image",
                descrizione: item.overview || item.description || "N/D",
                tags: Array.isArray(item.genres) ? item.genres : (Array.isArray(item.tags) ? item.tags : []), // Tags Anime/Serie
                stagioni: (item.seasons || item.stagioni || []).map((s, seasonIndex) => ({ 
                    id_stagione: s.id_stagione || generateId(s.name || s.title || s.season_name || `Stagione ${s.season_number || seasonIndex + 1}`, item.id + '_s' + seasonIndex + '-'),
                    stagione_numero: s.season_number || s.season_name || s.name || `Stagione ${seasonIndex + 1}`, // Nome/Numero Stagione
                    titolo_stagione: s.title || s.name || s.titolo_stagione, // Titolo specifico della Stagione
                    immagine_stagione: s.poster_path || s.image_stagione || item.poster_path || item.image || item.thumbnail,
                    season_index_internal: seasonIndex, 
                    episodes: (s.episodes || []).map((ep, episodeIndex) => ({
                        id_episodio: ep.id_episodio || generateId(ep.name || ep.title || `Episodio ${ep.episode_number || episodeIndex + 1}`, item.id + '_s' + seasonIndex + '_e' + episodeIndex + '-'),
                        episodio_numero: ep.episode_number || ep.episode || episodeIndex + 1, // Numero Episodio
                        titolo_episodio: ep.name || ep.title || `Episodio ${ep.episode_number || episodeIndex + 1}`, // Titolo Episodio
                        link: ep.video_url || ep.file || ep.link, // Link video
                        descrizione_episodio: ep.overview || ep.description_episodio,
                        immagine_episodio: ep.still_path || ep.image_episodio,
                        skipIntroStart: ep.skipIntroStart, 
                        skipIntroEnd: ep.skipIntroEnd,     
                        outroStart: ep.outroStart,         
                        episode_index_internal: episodeIndex,
                        type: type 
                    }))
                }))
            });

            function updateMainView(title, contentHtml, isGridView = false) {
                sectionTitleElement.textContent = title;
                itemsGrid.innerHTML = contentHtml;
                itemsGrid.className = isGridView ? 'grid-container' : 'detail-view-container';
            }
            
            function updateBackButton() {
                backButton.classList.toggle('hidden', breadcrumbs.length <= 1);
            }
            backButton.addEventListener('click', () => {
                if (breadcrumbs.length > 1) {
                    breadcrumbs.pop(); 
                    const previousState = breadcrumbs[breadcrumbs.length - 1];
                    window.location.hash = previousState.hash; 
                }
            });

            function playVideo(itemData, serieOrAnimeId, stagioneIndex, episodioIndex) {
                const videoLink = itemData.link || itemData.url_video;
                if (!videoLink) { alert("URL del video non trovato!"); return; }
                let playerUrl = `player.html?videoUrl=${encodeURIComponent(videoLink)}`;
                if (itemData.type !== 'film') { // Solo per serie/anime
                    if (itemData.skipIntroStart) playerUrl += `&skipIntroStart=${encodeURIComponent(itemData.skipIntroStart)}`;
                    if (itemData.skipIntroEnd) playerUrl += `&skipIntroEnd=${encodeURIComponent(itemData.skipIntroEnd)}`;
                    if (itemData.outroStart) playerUrl += `&outroStart=${encodeURIComponent(itemData.outroStart)}`;
                }
                if (serieOrAnimeId !== undefined) { 
                    playerUrl += `&serieId=${encodeURIComponent(serieOrAnimeId)}`;
                    playerUrl += `&stagioneIndex=${stagioneIndex}`;
                    playerUrl += `&episodioIndex=${episodioIndex}`;
                    playerUrl += `&contentType=${itemData.type}`;
                    playerUrl += `&returnTo=${encodeURIComponent(window.location.hash || '#home')}`;
                }
                window.location.href = playerUrl;
            }

            function createItemCard(item) {
                const card = document.createElement('div');
                card.className = 'card';
                let tagsHtml = '';
                if (item.tags && Array.isArray(item.tags) && item.tags.length > 0) {
                    const tagNames = item.tags.map(tag => (typeof tag === 'object' && tag.name) ? tag.name : (typeof tag === 'string' ? tag : null)).filter(Boolean);
                    if (tagNames.length > 0) {
                         tagsHtml = `<div class="tags-container">${tagNames.map(tag => `<span class="tag">${tag}</span>`).join('')}</div>`;
                    }
                }
                card.innerHTML = `<img src="${item.immagine}" alt="${item.titolo}"><div class="card-content"><h3>${item.titolo}</h3><p class="description">${item.descrizione || ''}</p>${tagsHtml}</div>`;
                card.addEventListener('click', () => {
                    if (item.type === 'film') {
                        if (item.url_video) playVideo(item);
                        else alert("URL video non disponibile.");
                    } else { 
                        window.location.hash = `#detail&type=${item.type}&id=${item.id}`;
                    }
                });
                return card;
            }

            function displaySerieDetail(item) { 
                currentView = 'serieDetail';
                let tagsHtml = '';
                if (item.tags && item.tags.length > 0) {
                    const tagNames = item.tags.map(tag => (typeof tag === 'object' && tag.name) ? tag.name : (typeof tag === 'string' ? tag : null)).filter(Boolean);
                     if (tagNames.length > 0) {
                        tagsHtml = `<div class="tags-container detail-tags">${tagNames.map(tag => `<span class="tag">${tag}</span>`).join('')}</div>`;
                    }
                }
                let seasonsHtml = '<p class="message">Nessuna stagione disponibile.</p>';
                if (item.stagioni && item.stagioni.length > 0) {
                    seasonsHtml = `<div class="seasons-grid">` + item.stagioni.map((stagione) => `
                        <div class="season-card" data-serie-id="${item.id}" data-season-index="${stagione.season_index_internal}" data-type="${item.type}">
                            <img src="${stagione.immagine_stagione || item.immagine}" alt="Stagione ${stagione.stagione_numero}">
                            <h4>Stagione ${stagione.stagione_numero} ${stagione.titolo_stagione ? ` - ${stagione.titolo_stagione}` : ''}</h4>
                            <p>${stagione.episodes ? stagione.episodes.length : 0} episodi</p>
                        </div>
                    `).join('') + `</div>`;
                }
                const contentHtml = `<div class="detail-header"><img src="${item.immagine}" alt="${item.titolo}"><div class="detail-header-info"><h3>${item.titolo}</h3><p>${item.descrizione || ''}</p>${tagsHtml}</div></div>${seasonsHtml}`;
                updateMainView(item.titolo, contentHtml);
                document.querySelectorAll('.season-card').forEach(card => {
                    card.addEventListener('click', () => {
                        window.location.hash = `#season&type=${card.dataset.type}&id=${card.dataset.serieId}&seasonIndex=${card.dataset.seasonIndex}`;
                    });
                });
            }

            function displaySeasonEpisodes(item, seasonIndex) { 
                currentView = 'seasonEpisodes';
                const stagione = item.stagioni[seasonIndex];
                if (!stagione) { updateMainView("Errore", "<p>Stagione non trovata.</p>"); return; }
                let episodesHtml = '<p class="message">Nessun episodio.</p>';
                if (stagione.episodes && stagione.episodes.length > 0) {
                    episodesHtml = `<ul class="episodes-list">` + stagione.episodes.map(ep => `
                        <li data-serie-id="${item.id}" data-season-index="${seasonIndex}" data-episode-index="${ep.episode_index_internal}" data-type="${item.type}">
                            <div class="episode-info">
                                ${ep.immagine_episodio ? `<img src="${ep.immagine_episodio}" alt="">` : `<div style="width:100px; height:56px; background:#333; display:flex; align-items:center; justify-content:center; border-radius:3px;"><span style="font-size:0.8em; color:#777;">No Img</span></div>`}
                                <div class="episode-title-desc">
                                   <span class="main-title">Ep. ${ep.episodio_numero}: ${ep.titolo_episodio}</span>
                                   ${ep.descrizione_episodio ? `<span class="ep-desc">${ep.descrizione_episodio}</span>` : ''}
                                </div>
                            </div>
                            <span class="play-icon">▶</span>
                        </li>
                    `).join('') + `</ul>`;
                }
                const seasonTitle = stagione.titolo_stagione ? `Stagione ${stagione.stagione_numero} - ${stagione.titolo_stagione}` : `Stagione ${stagione.stagione_numero}`;
                const contentHtml = `<div class="episodes-list-section"><h4>${seasonTitle} - Episodi</h4>${episodesHtml}</div>`;
                updateMainView(`${item.titolo} - ${seasonTitle}`, contentHtml);
                document.querySelectorAll('.episodes-list li').forEach(li => {
                    li.addEventListener('click', () => {
                        const serieId = li.dataset.serieId, sIndex = parseInt(li.dataset.seasonIndex), epIndex = parseInt(li.dataset.episodeIndex), type = li.dataset.type;
                        const collection = type === 'serietv' ? allSerieTv : allAnime;
                        const serieItem = collection.find(s => s.id === serieId);
                        const episodeData = serieItem?.stagioni[sIndex]?.episodes[epIndex];
                        if (episodeData && episodeData.link) playVideo(episodeData, serieId, sIndex, epIndex);
                        else alert("URL video non disponibile.");
                    });
                });
            }
            
            function playNextEpisodeLogic(serieId, currentStagioneIndex, currentEpisodioIndex, contentType) {
                const collection = contentType === 'serietv' ? allSerieTv : (contentType === 'anime' ? allAnime : null);
                if (!collection) { return; } const serie = collection.find(s => s.id === serieId); if (!serie) { return; }
                currentStagioneIndex = parseInt(currentStagioneIndex); currentEpisodioIndex = parseInt(currentEpisodioIndex);
                let nextEp, nextStagioneIndex = currentStagioneIndex, nextEpisodioIndex = currentEpisodioIndex + 1;

                if (serie.stagioni[currentStagioneIndex]?.episodes[nextEpisodioIndex]) {
                    nextEp = serie.stagioni[currentStagioneIndex].episodes[nextEpisodioIndex];
                } else { 
                    nextStagioneIndex = currentStagioneIndex + 1; nextEpisodioIndex = 0;
                    if (serie.stagioni[nextStagioneIndex]?.episodes[nextEpisodioIndex]) {
                        if (confirm(`Hai terminato Stagione ${serie.stagioni[currentStagioneIndex].stagione_numero}. Prossima Stagione (${serie.stagioni[nextStagioneIndex].stagione_numero})?`)) {
                            nextEp = serie.stagioni[nextStagioneIndex].episodes[nextEpisodioIndex];
                        } else { window.location.hash = `#detail&type=${contentType}&id=${serieId}`; return; }
                    } else { alert(`Hai completato ${serie.titolo}!`); window.location.hash = `#home`; return; }
                }
                if (nextEp && nextEp.link) playVideo(nextEp, serieId, nextStagioneIndex, nextEpisodioIndex);
                else { window.location.hash = `#detail&type=${contentType}&id=${serieId}`; }
            }

            function displayGrid(items, title) { currentView = 'grid'; updateMainView(title, items.map(item => createItemCard(item).outerHTML).join(''), true); }
            function displayHome() { setActiveNav(navHome); displayGrid(getRandomItems(allContent, 12), 'Home - Consigliati'); }
            function getRandomItems(array, count) { if (!array || array.length === 0) return []; const shuffled = [...array].sort(() => 0.5 - Math.random()); return shuffled.slice(0, Math.min(count, shuffled.length)); }
            function displayFilm() { setActiveNav(navFilm); displayGrid(allFilm, 'Tutti i Film'); }
            function displaySerieTv() { setActiveNav(navSerieTv); displayGrid(allSerieTv, 'Tutte le Serie TV'); }
            function displayAnime() { setActiveNav(navAnime); displayGrid(allAnime, 'Tutti gli Anime'); }
            
            function handleSearch() { 
                const searchTerm = searchInput.value.toLowerCase().trim(); 
                // Non modificare l'hash qui, sarà fatto da chi chiama handleSearch se necessario
                if (!searchTerm) { 
                    // Se la ricerca è vuota, torna alla vista precedente salvata nei breadcrumbs
                    if(breadcrumbs.length > 1 && breadcrumbs[breadcrumbs.length-1].hash.startsWith("#search")) {
                        breadcrumbs.pop(); // Rimuovi l'hash della ricerca corrente
                    }
                    window.location.hash = breadcrumbs.length > 0 ? breadcrumbs[breadcrumbs.length - 1].hash : '#home';
                    return;
                }
                const filtered = allContent.filter(item => (item.titolo.toLowerCase().includes(searchTerm) || 
                    (item.tags && item.tags.some(tag => ((typeof tag === 'object' && tag.name) ? tag.name : (typeof tag === 'string' ? tag : '')).toLowerCase().includes(searchTerm))))); 
                
                const searchTitle = `Ricerca: "${searchInput.value}"`;
                displayGrid(filtered, searchTitle); 
                setActiveNav(null);
                // Non aggiornare i breadcrumbs qui se handleSearch è chiamato da handleRouteChange per #search
            }

            function setActiveNav(activeLink) { [navHome, navFilm, navSerieTv, navAnime].forEach(link => { if (link) link.classList.remove('active'); }); if (activeLink) { activeLink.classList.add('active'); } }
            
            function handleRouteChange(initialLoad = false) {
                const rawHash = window.location.hash || '#home';
                let pageTitle = "Catalogo"; // Titolo di default per il breadcrumb

                if (rawHash.startsWith('#playNext')) {
                    const params = new URLSearchParams(rawHash.substring(rawHash.indexOf('?') + 1));
                    const serieId = params.get('serieId'), stagIdx = params.get('stagioneIndex'), epIdx = params.get('episodioIndex'), cType = params.get('contentType');
                    const prevHashForHistory = breadcrumbs.length > 0 ? breadcrumbs[breadcrumbs.length - 1].hash : '#home';
                    history.replaceState(null, null, window.location.pathname + window.location.search + prevHashForHistory); 
                    if (serieId && stagIdx !== null && epIdx !== null && cType) {
                        if (allContent.length > 0) playNextEpisodeLogic(serieId, stagIdx, epIdx, cType);
                        else fetchData().then(() => playNextEpisodeLogic(serieId, stagIdx, epIdx, cType));
                    }
                    return; 
                }

                if (initialLoad) {
                    breadcrumbs = [{hash: rawHash, title: pageTitle}]; // Il titolo sarà aggiornato sotto
                } else {
                    const existingCrumbIndex = breadcrumbs.findIndex(b => b.hash === rawHash);
                    if (existingCrumbIndex !== -1) {
                        breadcrumbs = breadcrumbs.slice(0, existingCrumbIndex + 1);
                        pageTitle = breadcrumbs[existingCrumbIndex].title; // Ripristina titolo
                    } else { 
                        breadcrumbs.push({hash: rawHash, title: pageTitle}); // Aggiungi, il titolo sarà aggiornato
                    }
                }
                if (breadcrumbs.length > 10) breadcrumbs.shift();

                const parts = rawHash.substring(1).split('&');
                const route = parts[0];
                const params = new URLSearchParams(parts.slice(1).join('&'));

                switch (route) {
                    case 'film': pageTitle = 'Tutti i Film'; displayFilm(); break;
                    case 'serietv': pageTitle = 'Tutte le Serie TV'; displaySerieTv(); break;
                    case 'anime': pageTitle = 'Tutti gli Anime'; displayAnime(); break;
                    case 'detail': {
                        const type = params.get('type'), id = params.get('id');
                        const collection = type === 'serietv' ? allSerieTv : allAnime;
                        const item = collection.find(s => s.id === id);
                        if (item) { pageTitle = item.titolo; displaySerieDetail(item); }
                        else { window.location.hash = '#home'; }
                        break;
                    }
                    case 'season': {
                        const type = params.get('type'), id = params.get('id'), seasonIndex = parseInt(params.get('seasonIndex'));
                        const collection = type === 'serietv' ? allSerieTv : allAnime;
                        const item = collection.find(s => s.id === id);
                        if (item && item.stagioni[seasonIndex]) {
                            const season = item.stagioni[seasonIndex];
                            pageTitle = `${item.titolo} - S${season.stagione_numero}`;
                            displaySeasonEpisodes(item, seasonIndex);
                        } else { window.location.hash = '#home'; }
                        break;
                    }
                     case 'search': {
                        const query = params.get('q');
                        pageTitle = `Ricerca: "${query || ''}"`;
                        if (query) { searchInput.value = query; handleSearch(); } 
                        else { window.location.hash = '#home'; } // Se la query è vuota, torna a home
                        break;
                    }
                    case 'home': default: pageTitle = 'Home'; displayHome(); break;
                }
                if(breadcrumbs.length > 0 && breadcrumbs[breadcrumbs.length - 1].hash === rawHash) {
                     breadcrumbs[breadcrumbs.length - 1].title = pageTitle;
                }
                updateBackButton();
            }

            [navHome, navFilm, navSerieTv, navAnime].forEach(navLink => { 
                navLink.addEventListener('click', (e) => {
                    const targetHash = e.currentTarget.getAttribute('href');
                    if (window.location.hash === targetHash) {
                        breadcrumbs = [{hash: targetHash, title: ''}];
                        handleRouteChange(true); 
                    } else {
                         breadcrumbs = [{hash: targetHash, title: ''}];
                         // L'hashchange event gestirà il resto
                    }
                }); 
            });
            window.addEventListener('hashchange', () => handleRouteChange(false));
            searchButton.addEventListener('click', () => { const query = searchInput.value.trim(); if (query) window.location.hash = `#search&q=${encodeURIComponent(query)}`; });
            searchInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') searchButton.click(); });

            fetchData();
        });
    </script>
</body>
</html>
