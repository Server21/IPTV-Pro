<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Player Universale - Controlli Animati e Volume</title>
  <style>
    body {
      margin: 0;
      background: #121212;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: #fff;
    }
    .player-container {
      position: relative;
      width: 80%;
      max-width: 900px;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
    }
    .player-container.fullscreen {
      transform: scale(1.02); /* Potrebbe non essere necessario se il fullscreen √® nativo */
      box-shadow: 0 0 0 rgba(0,0,0,0);
    }
    video {
      width: 100%;
      display: block;
      border-radius: 12px; /* Rimuovi se vuoi che il video riempia il contenitore in fullscreen */
      background: #000;
      cursor: pointer;
    }
    .pause-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 64px;
      color: rgba(255,255,255,0.8);
      display: none;
      animation: fade 0.5s ease-in-out;
      pointer-events: none;
    }
    @keyframes fade { from { opacity: 0; } to { opacity: 1; } }
    .controls {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.6);
      padding: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
      opacity: 1;
      transition: opacity 0.5s ease;
    }
    .controls.hidden {
      opacity: 0;
    }
    .control-button {
      background: none;
      border: none;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      transition: background-color 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 32px;
      height: 32px;
    }
    .control-button:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }
    .progress-bar {
      position: relative;
      flex: 1;
      height: 6px;
      background: #444;
      cursor: pointer;
      border-radius: 3px;
    }
    .progress-filled {
      width: 0;
      height: 100%;
      background: #00ff00;
      border-radius: 3px;
      transition: width 0.1s ease; /* Transizione pi√π fluida per il riempimento */
    }
    .progress-buffered {
      position: absolute;
      top: 0;
      left: 0;
      width: 0;
      height: 100%;
      background: #0066ff; /* Blu per il buffer */
      border-radius: 3px;
      opacity: 0.7;
      z-index: 1; /* Sotto il filled e handle */
    }
    .progress-handle {
      position: absolute;
      top: 50%;
      left: 0; /* Si aggiorna con JS */
      width: 12px;
      height: 12px;
      background: #00ff00;
      border: 2px solid #fff;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s ease, transform 0.2s ease;
      z-index: 3; /* Sopra filled e buffered */
    }
    .progress-bar:hover .progress-handle {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
    }
    .progress-handle.dragging {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.3);
    }
    .preview-thumb {
      position: absolute;
      bottom: 100%; /* Posiziona sopra la progress bar */
      left: 0; /* Sar√† aggiustato da JS */
      width: 120px;
      height: 68px; /* 16:9 aspect ratio comune */
      margin-bottom: 4px; /* Spazio dalla progress bar */
      background: #000;
      border: 1px solid #555;
      display: none; /* Mostrato da JS */
      pointer-events: none; /* Non interferisce con il mouse sulla progress bar */
    }
    .preview-thumb video { width: 100%; height: 100%; object-fit: cover; }
    .tooltip {
      position: absolute;
      bottom: 100%; /* Posiziona sopra la progress bar */
      padding: 2px 4px;
      background: rgba(0,0,0,0.8);
      color: #fff; font-size:12px;
      border-radius:2px;
      transform: translateX(-50%); /* Centra rispetto al cursore */
      display: none; /* Mostrato da JS */
      white-space:nowrap;
      margin-bottom: 4px; /* Spazio dalla progress bar, simile a preview-thumb */
      pointer-events: none;
    }
    .volume-control {
      display: flex; align-items: center; gap:4px;
    }
    .volume-control input[type=range] {
      width: 80px;
    }
    select {
      background: #1f1f1f; color: #fff; border: none; border-radius:4px; padding:4px;
      cursor: pointer;
    }
    span#time-display { color: #fff; font-size: 0.9em; }
  </style>
</head>
<body>
  <!-- Configurazione MODIFICATA -->
  <script>
    // Ottieni l'URL del video e altri parametri dalla query string
    const urlParams = new URLSearchParams(window.location.search);
    const videoUrlFromQuery = urlParams.get('videoUrl'); // Il parametro si chiamer√† 'videoUrl'
    const startTimeFromQuery = urlParams.get('startTime'); 
    const skipIntroStartFromQuery = urlParams.get('skipIntroStart');
    const skipIntroEndFromQuery = urlParams.get('skipIntroEnd');
    const outroStartFromQuery = urlParams.get('outroStart');

    const CONFIG = {
      source: videoUrlFromQuery || 'https://sample-videos.com/video123/mp4/720/big_buck_bunny_720p_1mb.mp4', // Usa l'URL dalla query o un fallback
      startTime: startTimeFromQuery || '0:00',
      skipIntroStart: skipIntroStartFromQuery || '0:00', // Lascia a 0:00 se non vuoi skip intro di default
      skipIntroEnd: skipIntroEndFromQuery || '0:00',   // Lascia a 0:00 se non vuoi skip intro di default
      outroStart: outroStartFromQuery || '99:99'     // Default a un tempo elevato se non specificato
    };
    function parseTime(val){ if(typeof val==='string'&&val.includes(':')){ const [m,s]=val.split(':').map(n=>parseInt(n,10)); return (m||0)*60+(s||0);} else if(typeof val==='number') return val*60; return 0; }
    const startTime=parseTime(CONFIG.startTime), skipIntroStart=parseTime(CONFIG.skipIntroStart), skipIntroEnd=parseTime(CONFIG.skipIntroEnd), outroStart=parseTime(CONFIG.outroStart);
  </script>
  <div class="player-container" id="playerContainer">
    <video id="video" playsinline></video> <!-- Rimosso autoplay per dare controllo all'utente o a loadSource -->
    <div class="pause-overlay" id="pauseOverlay">‚è∏Ô∏è</div>
    <div id="loading" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);display:none;color:#fff;">Loading...</div>
    <div class="controls" id="controls">
      <button class="control-button" id="playPauseBtn" title="Play/Pause">‚ñ∂Ô∏è</button>
      <span id="time-display">00:00 / 00:00</span>
      <div class="progress-bar" id="progress-bar">
        <div class="progress-buffered" id="progress-buffered"></div>
        <div class="progress-filled" id="progress-filled"></div>
        <div class="progress-handle" id="progress-handle"></div>
        <div class="preview-thumb" id="preview-thumb"><video muted></video></div>
        <div class="tooltip" id="tooltip">00:00</div>
      </div>
      <div class="volume-control">
        <span id="volumeIcon">üîä</span>
        <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1">
      </div>
      <select id="speed-selector" title="Velocit√†">
        <option value="0.5">0.5x</option><option value="0.75">0.75x</option>
        <option value="1" selected>1x</option><option value="1.25">1.25x</option>
        <option value="1.5">1.5x</option><option value="2">2x</option>
      </select>
      <button class="control-button" id="fullscreenBtn" title="Fullscreen">‚õ∂</button>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script>
    const playerContainer=document.getElementById('playerContainer'), video=document.getElementById('video'), pauseOverlay=document.getElementById('pauseOverlay'),
      controls=document.getElementById('controls'), progressBar=document.getElementById('progress-bar'), progressFilled=document.getElementById('progress-filled'),
      progressBuffered=document.getElementById('progress-buffered'), progressHandle=document.getElementById('progress-handle'), timeDisplay=document.getElementById('time-display'), loadingEl=document.getElementById('loading'), previewThumb=document.getElementById('preview-thumb'),
      previewVideo=previewThumb.querySelector('video'), tooltip=document.getElementById('tooltip'), speedSelector=document.getElementById('speed-selector'), 
      volumeSlider=document.getElementById('volumeSlider'), volumeIcon = document.getElementById('volumeIcon'), playPauseBtn=document.getElementById('playPauseBtn'), fullscreenBtn=document.getElementById('fullscreenBtn');

    let isDragging = false;
    let hideControlsTimeout;

    function togglePlayPause() {
      if (video.paused || video.ended) {
        video.play();
      } else {
        video.pause();
      }
    }

    playPauseBtn.addEventListener('click', togglePlayPause);
    video.addEventListener('click', togglePlayPause);

    video.addEventListener('play', () => {
      playPauseBtn.textContent = '‚è∏Ô∏è';
      pauseOverlay.style.display = 'none'; // Nascondi overlay quando si avvia la riproduzione
    });
    video.addEventListener('pause', () => {
      playPauseBtn.textContent = '‚ñ∂Ô∏è';
      if (!isDragging) { // Mostra overlay solo se la pausa non √® dovuta al trascinamento
        pauseOverlay.style.display = 'block';
        setTimeout(() => pauseOverlay.style.display = 'none', 600);
      }
    });
     video.addEventListener('ended', () => {
        playPauseBtn.textContent = '‚ñ∂Ô∏è'; // Mostra il pulsante play alla fine
    });

    function updateBufferedBar() {
      if (!isFinite(video.duration) || video.buffered.length === 0) {
        progressBuffered.style.width = '0%';
        return;
      }
      
      let bufferedEnd = 0;
      for (let i = 0; i < video.buffered.length; i++) {
        // Trova il range di buffer che contiene o √® subito dopo il tempo corrente
        if (video.buffered.start(i) <= video.currentTime && video.currentTime < video.buffered.end(i)) {
          bufferedEnd = video.buffered.end(i);
          break;
        } else if (video.buffered.start(i) > video.currentTime) {
            // Se non c'√® un buffer al tempo corrente, prendi l'inizio del prossimo
            bufferedEnd = video.buffered.start(i); 
            // O, pi√π comunemente, si vuole il buffer pi√π avanzato relativo al tempo corrente
            if (video.buffered.length > 0) { // Cerca il buffer pi√π esteso
                for(let j=0; j < video.buffered.length; j++){
                    if(video.buffered.end(j) > bufferedEnd) bufferedEnd = video.buffered.end(j);
                }
            }
            break; 
        }
      }
      // Se nessun buffer √® avanti, ma c'√® buffer dietro, consideriamo l'ultimo punto bufferizzato
      if (bufferedEnd === 0 && video.buffered.length > 0) {
        bufferedEnd = video.buffered.end(video.buffered.length - 1);
      }

      const bufferedPercent = (bufferedEnd / video.duration) * 100;
      progressBuffered.style.width = `${Math.min(100, bufferedPercent)}%`;
    }
    
    video.addEventListener('progress', updateBufferedBar);
    video.addEventListener('loadedmetadata', updateBufferedBar); // Chiamala anche qui
    video.addEventListener('canplaythrough', updateBufferedBar);


    fullscreenBtn.addEventListener('click', () => {
      if (!document.fullscreenElement) {
        playerContainer.requestFullscreen().catch(err => {
          alert(`Errore nell'entrare in fullscreen: ${err.message} (${err.name})`);
        });
      } else {
        document.exitFullscreen();
      }
    });
    document.addEventListener('fullscreenchange', () => {
      playerContainer.classList.toggle('fullscreen', !!document.fullscreenElement);
      showControls(); // Aggiorna la visibilit√† dei controlli in base allo stato fullscreen
    });
    video.addEventListener('dblclick', () => {
      if (!document.fullscreenElement) {
        playerContainer.requestFullscreen().catch(err => {/* gestisci errore */});
      } else {
        document.exitFullscreen();
      }
    });

    volumeSlider.addEventListener('input', () => {
      video.volume = parseFloat(volumeSlider.value);
      video.muted = video.volume === 0;
    });
    video.addEventListener('volumechange', () => {
        volumeSlider.value = video.muted ? 0 : video.volume;
        if (video.muted || video.volume === 0) {
            volumeIcon.textContent = 'üîá';
        } else if (video.volume < 0.5) {
            volumeIcon.textContent = 'üîâ';
        } else {
            volumeIcon.textContent = 'üîä';
        }
    });
    volumeIcon.addEventListener('click', () => {
        video.muted = !video.muted;
    });


    speedSelector.addEventListener('change', () => video.playbackRate = parseFloat(speedSelector.value));

    let hlsInstance = null;
    function loadSource(src) {
        loadingEl.style.display = 'block';
        video.poster = ''; // Rimuovi il poster se presente

        if (hlsInstance) {
            hlsInstance.destroy(); // Distruggi istanza HLS precedente se esiste
            hlsInstance = null;
        }

        if (src.includes('.m3u8')) {
            if (Hls.isSupported()) {
                hlsInstance = new Hls();
                hlsInstance.loadSource(src);
                hlsInstance.attachMedia(video);
                hlsInstance.on(Hls.Events.MANIFEST_PARSED, () => {
                    loadingEl.style.display = 'none';
                    if (startTime > 0 && startTime < video.duration) video.currentTime = startTime;
                    video.play(); // Autoplay dopo il caricamento HLS
                });
                hlsInstance.on(Hls.Events.ERROR, function (event, data) {
                    console.error('HLS Error:', data);
                    loadingEl.style.display = 'none';
                    if (data.fatal) {
                        switch(data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                console.error("fatal network error encountered, try to recover");
                                hlsInstance.startLoad();
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.error("fatal media error encountered, try to recover");
                                hlsInstance.recoverMediaError();
                                break;
                            default:
                                hlsInstance.destroy();
                                break;
                        }
                    }
                });
                // Per preview con HLS, potresti aver bisogno di una seconda istanza
                if (previewVideo.canPlayType('application/vnd.apple.mpegurl')) {
                    previewVideo.src = src;
                } else if (Hls.isSupported()) {
                    const hlsPreview = new Hls();
                    hlsPreview.loadSource(src);
                    hlsPreview.attachMedia(previewVideo);
                }


            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                video.src = src;
                previewVideo.src = src; // Anche per la preview
            } else {
                alert('HLS non √® supportato su questo browser.');
                loadingEl.style.display = 'none';
            }
        } else { // Per MP4 e altri formati diretti
            video.src = src;
            previewVideo.src = src; // Imposta sorgente anche per video di anteprima
        }

        video.onloadedmetadata = () => {
            if (!src.includes('.m3u8')) loadingEl.style.display = 'none'; // Nascondi solo se non √® HLS (gestito da MANIFEST_PARSED)
            updateTime();
            updateBufferedBar();
            if (startTime > 0 && startTime < video.duration) video.currentTime = startTime;
            if (!src.includes('.m3u8')) video.play(); // Autoplay per non HLS
        };
        video.onerror = (e) => {
            console.error("Errore caricamento video:", e);
            loadingEl.style.display = 'none';
            alert("Impossibile caricare il video.");
        };
    }


    function formatTime(s) {
      if (isNaN(s) || s === Infinity) return '00:00';
      const m = Math.floor(s / 60).toString().padStart(2, '0');
      const sec = Math.floor(s % 60).toString().padStart(2, '0');
      return `${m}:${sec}`;
    }
    function updateTime() {
      if (!isFinite(video.duration)) {
        timeDisplay.textContent = `${formatTime(video.currentTime)} / --:--`;
      } else {
        timeDisplay.textContent = `${formatTime(video.currentTime)} / ${formatTime(video.duration)}`;
      }
    }
    video.addEventListener('loadedmetadata', updateTime); // Assicura che la durata sia aggiornata
    video.addEventListener('timeupdate', updateTime); // Aggiorna il tempo corrente


    function showControls() {
      controls.classList.remove('hidden');
      clearTimeout(hideControlsTimeout);
      if (!video.paused && (document.fullscreenElement || playerContainer.contains(document.activeElement))) { // Nascondi solo se in play e fullscreen o focus nel player
        hideControlsTimeout = setTimeout(() => controls.classList.add('hidden'), 3000);
      }
    }
    playerContainer.addEventListener('mousemove', showControls);
    playerContainer.addEventListener('mouseleave', () => { // Nascondi quando il mouse esce dal player (se non in pausa)
        if (!video.paused) clearTimeout(hideControlsTimeout); // Cancella timeout precedente
        hideControlsTimeout = setTimeout(() => controls.classList.add('hidden'), 500);
    });
    controls.addEventListener('mouseenter', () => clearTimeout(hideControlsTimeout)); // Non nascondere se il mouse √® sui controlli
    controls.addEventListener('mouseleave', showControls); // Riattiva il timer se il mouse esce dai controlli


    video.addEventListener('timeupdate', () => {
      if (!isFinite(video.duration)) return;
      if (!isDragging) {
        const progressPercent = (video.currentTime / video.duration) * 100;
        progressFilled.style.width = `${progressPercent}%`;
        progressHandle.style.left = `${progressPercent}%`;
      }
      updateTime();
      updateBufferedBar(); // Aggiorna anche il buffer qui
      
      if (skipIntroStart > 0 && skipIntroEnd > 0 && video.currentTime >= skipIntroStart && video.currentTime < skipIntroEnd) {
        video.currentTime = skipIntroEnd;
      }
      if (outroStart > 0 && video.currentTime >= outroStart && video.currentTime < video.duration -1 && !video.paused) { // -1 per evitare conflitti con 'ended'
        video.pause();
        // video.currentTime = outroStart; // Opzionale: riporta esattamente all'inizio dell'outro
      }
    });

    function seek(e) {
      const progressBarRect = progressBar.getBoundingClientRect();
      const clickPositionInBar = e.clientX - progressBarRect.left;
      const time = (clickPositionInBar / progressBarRect.width) * video.duration;
      if (isFinite(time)) video.currentTime = time;
    }

    progressBar.addEventListener('click', seek);

    progressHandle.addEventListener('mousedown', (e) => {
      isDragging = true;
      progressHandle.classList.add('dragging');
      document.body.style.userSelect = 'none'; // Evita selezione testo durante drag
      e.preventDefault(); // Evita comportamenti di default del browser
    });

    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const progressBarRect = progressBar.getBoundingClientRect();
        let newLeft = e.clientX - progressBarRect.left;
        let percentage = (newLeft / progressBarRect.width) * 100;
        percentage = Math.max(0, Math.min(100, percentage)); // Limita tra 0 e 100

        progressFilled.style.width = `${percentage}%`;
        progressHandle.style.left = `${percentage}%`;
        
        // Aggiorna il tempo del video solo se il mouse √® effettivamente sopra la progress bar
        // per evitare scatti se il mouse esce e rientra durante il drag.
        // O, pi√π semplicemente, aggiorna sempre se isDragging √® true.
        if (isFinite(video.duration)) {
             video.currentTime = (percentage / 100) * video.duration;
        }
        updateTime(); // Aggiorna il display del tempo durante il drag
      }
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        progressHandle.classList.remove('dragging');
        document.body.style.userSelect = ''; // Ripristina selezione testo
        // Il currentTime √® gi√† stato aggiornato durante il mousemove
      }
    });

    progressBar.addEventListener('mousemove', e => {
      if (isDragging || !isFinite(video.duration)) return;
      const r = progressBar.getBoundingClientRect();
      const hoverPos = e.clientX - r.left;
      const percentage = (hoverPos / r.width);
      const time = percentage * video.duration;

      if (previewVideo.src && isFinite(time)) { // Solo se c'√® una sorgente per la preview
          previewVideo.currentTime = time;
          previewThumb.style.left = `${Math.max(0, Math.min(hoverPos - previewThumb.offsetWidth / 2, r.width - previewThumb.offsetWidth))}px`;
          previewThumb.style.display = 'block';
      }
      
      tooltip.style.left = `${Math.max(0, Math.min(hoverPos, r.width))}px`;
      tooltip.textContent = formatTime(time);
      tooltip.style.display = 'block';
    });
    progressBar.addEventListener('mouseout', () => {
      if (!isDragging) { // Non nascondere se sto ancora trascinando
        previewThumb.style.display = 'none';
        tooltip.style.display = 'none';
      }
    });
    
    // Inizializzazione
    showControls(); // Mostra i controlli all'inizio
    video.volume = parseFloat(volumeSlider.value); // Imposta volume iniziale
    video.playbackRate = parseFloat(speedSelector.value); // Imposta velocit√† iniziale
    
    // Carica la sorgente video principale
    if (CONFIG.source) {
        loadSource(CONFIG.source);
    } else {
        console.error("Nessuna sorgente video fornita nella configurazione.");
        loadingEl.style.display = 'none';
        alert("Nessun video da caricare.");
    }

  </script>
</body>
</html>
